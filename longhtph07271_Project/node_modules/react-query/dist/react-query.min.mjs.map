{"version":3,"file":"react-query.min.mjs","sources":["../src/core/types.ts","../src/core/utils.ts","../src/core/config.ts","../src/core/queryInstance.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/setFocusHandler.ts","../src/react/ReactQueryCacheProvider.tsx","../src/react/ReactQueryConfigProvider.tsx","../src/react/useMutation.ts","../src/react/utils.ts","../src/react/useIsFetching.ts","../src/react/useBaseQuery.ts","../src/react/useQueryArgs.ts","../src/react/useQuery.ts","../src/react/usePaginatedQuery.ts","../src/react/useInfiniteQuery.ts"],"sourcesContent":["import { Query, FetchMoreOptions } from './query'\n\nexport type QueryKeyObject =\n  | object\n  | { [key: string]: QueryKey }\n  | { [key: number]: QueryKey }\n\nexport type QueryKeyPrimitive = string | boolean | number | null | undefined\n\nexport type QueryKeyWithoutObjectAndArray = QueryKeyPrimitive\n\nexport type QueryKeyWithoutObject =\n  | QueryKeyWithoutObjectAndArray\n  | readonly QueryKey[]\n\nexport type QueryKeyWithoutArray =\n  | QueryKeyWithoutObjectAndArray\n  | QueryKeyObject\n\nexport type QueryKey = QueryKeyWithoutObject | QueryKeyObject\n\nexport type ArrayQueryKey = QueryKey[]\n\nexport type QueryFunction<TResult> = (\n  ...args: any[]\n) => TResult | Promise<TResult>\n\n// The tuple variants are only to infer types in the public API\nexport type TupleQueryKey = readonly [QueryKey, ...QueryKey[]]\n\nexport type TupleQueryFunction<TResult, TKey extends TupleQueryKey> = (\n  ...args: TKey\n) => TResult | Promise<TResult>\n\nexport type InitialDataFunction<TResult> = () => TResult | undefined\n\nexport type InitialStaleFunction = () => boolean\n\nexport type QueryKeySerializerFunction = (\n  queryKey: QueryKey\n) => [string, QueryKey[]]\n\nexport interface BaseQueryConfig<TResult, TError = unknown> {\n  /**\n   * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   */\n  enabled?: boolean | unknown\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: boolean | number | ((failureCount: number, error: TError) => boolean)\n  retryDelay?: number | ((retryAttempt: number) => number)\n  staleTime?: number\n  cacheTime?: number\n  refetchInterval?: false | number\n  refetchIntervalInBackground?: boolean\n  refetchOnWindowFocus?: boolean\n  refetchOnMount?: boolean\n  onSuccess?: (data: TResult) => void\n  onError?: (err: TError) => void\n  onSettled?: (data: TResult | undefined, error: TError | null) => void\n  isDataEqual?: (oldData: unknown, newData: unknown) => boolean\n  useErrorBoundary?: boolean\n  queryFn?: QueryFunction<TResult>\n  queryKeySerializerFn?: QueryKeySerializerFunction\n  queryFnParamsFilter?: (args: ArrayQueryKey) => ArrayQueryKey\n  suspense?: boolean\n  initialData?: TResult | InitialDataFunction<TResult>\n  initialStale?: boolean | InitialStaleFunction\n  infinite?: true\n}\n\nexport interface QueryConfig<TResult, TError = unknown>\n  extends BaseQueryConfig<TResult, TError> {}\n\nexport interface PaginatedQueryConfig<TResult, TError = unknown>\n  extends BaseQueryConfig<TResult, TError> {}\n\nexport interface InfiniteQueryConfig<TResult, TError = unknown>\n  extends BaseQueryConfig<TResult[], TError> {\n  getFetchMore: (lastPage: TResult, allPages: TResult[]) => unknown\n}\n\nexport type IsFetchingMoreValue = 'previous' | 'next' | false\n\nexport enum QueryStatus {\n  Idle = 'idle',\n  Loading = 'loading',\n  Error = 'error',\n  Success = 'success',\n}\n\nexport interface QueryResultBase<TResult, TError = unknown> {\n  status: QueryStatus\n  error: TError | null\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  isIdle: boolean\n  isFetching: boolean\n  isStale: boolean\n  failureCount: number\n  query: Query<TResult, TError>\n  updatedAt: number\n  refetch: () => Promise<void>\n  clear: () => void\n}\n\nexport interface QueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {\n  data: TResult | undefined\n}\n\nexport interface PaginatedQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {\n  resolvedData: TResult | undefined\n  latestData: TResult | undefined\n}\n\nexport interface InfiniteQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult[], TError> {\n  data: TResult[] | undefined\n  isFetchingMore?: IsFetchingMoreValue\n  canFetchMore: boolean | undefined\n  fetchMore: (\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ) => Promise<TResult[] | undefined> | undefined\n}\n\nexport interface MutateConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> {\n  onSuccess?: (data: TResult, variables: TVariables) => Promise<void> | void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    snapshotValue: TSnapshot\n  ) => Promise<void> | void\n  onSettled?: (\n    data: undefined | TResult,\n    error: TError | null,\n    variables: TVariables,\n    snapshotValue?: TSnapshot\n  ) => Promise<void> | void\n  throwOnError?: boolean\n}\n\nexport interface MutationConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutateConfig<TResult, TError, TVariables, TSnapshot> {\n  onMutate?: (variables: TVariables) => Promise<TSnapshot> | TSnapshot\n  useErrorBoundary?: boolean\n  suspense?: boolean\n}\n\nexport type MutationFunction<TResult, TVariables = unknown> = (\n  variables: TVariables\n) => Promise<TResult>\n\nexport type MutateFunction<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> = (\n  variables?: TVariables,\n  config?: MutateConfig<TResult, TError, TVariables, TSnapshot>\n) => Promise<TResult | undefined>\n\nexport type MutationResultPair<TResult, TError, TVariables, TSnapshot> = [\n  MutateFunction<TResult, TError, TVariables, TSnapshot>,\n  MutationResult<TResult, TError>\n]\n\nexport interface MutationResult<TResult, TError = unknown> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  reset: () => void\n}\n\nexport interface ReactQueryConfig<TResult = unknown, TError = unknown> {\n  queries?: ReactQueryQueriesConfig<TResult, TError>\n  shared?: ReactQuerySharedConfig\n  mutations?: ReactQueryMutationsConfig<TResult, TError>\n}\n\nexport interface ReactQuerySharedConfig {\n  suspense?: boolean\n}\n\nexport interface ReactQueryQueriesConfig<TResult, TError>\n  extends BaseQueryConfig<TResult, TError> {}\n\nexport interface ReactQueryMutationsConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutationConfig<TResult, TError, TVariables, TSnapshot> {}\n","import { QueryConfig, QueryStatus, QueryKey, QueryFunction } from './types'\n\n// TYPES\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\ntype ConsoleFunction = (...args: any[]) => void\n\nexport interface ConsoleObject {\n  log: ConsoleFunction\n  warn: ConsoleFunction\n  error: ConsoleFunction\n}\n\n// UTILS\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport const globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport function noop(): void {\n  return void 0\n}\nexport function identity<T>(d: T): T {\n  return d\n}\nexport let Console: ConsoleObject = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function setConsole(c: ConsoleObject) {\n  Console = c\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nfunction stableStringifyReplacer(_key: string, value: any): unknown {\n  if (typeof value === 'function') {\n    throw new Error('Cannot stringify non JSON value')\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value)\n      .sort()\n      .reduce((result, key) => {\n        result[key] = value[key]\n        return result\n      }, {} as any)\n  }\n\n  return value\n}\n\nexport function stableStringify(value: any): string {\n  return JSON.stringify(value, stableStringifyReplacer)\n}\n\nexport function isObject(a: unknown): boolean {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible(): boolean {\n  const visibilityState = document?.visibilityState as any\n\n  return [undefined, 'visible', 'prerender'].includes(visibilityState)\n}\n\nexport function isOnline(): boolean {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs<TResult, TError, TOptions = undefined>(\n  args: any[]\n): [QueryKey, QueryConfig<TResult, TError>, TOptions] {\n  let queryKey: QueryKey\n  let queryFn: QueryFunction<TResult> | undefined\n  let config: QueryConfig<TResult, TError> | undefined\n  let options: TOptions\n\n  if (isObject(args[0])) {\n    queryKey = args[0].queryKey\n    queryFn = args[0].queryFn\n    config = args[0].config\n    options = args[1]\n  } else if (isObject(args[1])) {\n    queryKey = args[0]\n    config = args[1]\n    options = args[2]\n  } else {\n    queryKey = args[0]\n    queryFn = args[1]\n    config = args[2]\n    options = args[3]\n  }\n\n  config = config || {}\n\n  if (queryFn) {\n    config = { ...config, queryFn }\n  }\n\n  return [queryKey, config, options]\n}\n\nexport function deepEqual(a: any, b: any): boolean {\n  return equal(a, b, true)\n}\n\nexport function shallowEqual(a: any, b: any): boolean {\n  return equal(a, b, false)\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nfunction equal(a: any, b: any, deep: boolean, depth = 0): boolean {\n  if (a === b) return true\n\n  if (\n    (deep || !depth) &&\n    a &&\n    b &&\n    typeof a == 'object' &&\n    typeof b == 'object'\n  ) {\n    let length, i\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; )\n        if (!equal(a[i], b[i], deep, depth + 1)) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    const keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      const key = keys[i]\n\n      if (!equal(a[key], b[key], deep, depth + 1)) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle,\n  }\n}\n","import { stableStringify, identity, deepEqual } from './utils'\nimport {\n  ArrayQueryKey,\n  QueryKey,\n  QueryKeySerializerFunction,\n  ReactQueryConfig,\n} from './types'\n\n// TYPES\n\nexport interface ReactQueryConfigRef {\n  current: ReactQueryConfig\n}\n\n// CONFIG\n\nexport const defaultQueryKeySerializerFn: QueryKeySerializerFunction = (\n  queryKey: QueryKey\n): [string, ArrayQueryKey] => {\n  try {\n    let arrayQueryKey: ArrayQueryKey = Array.isArray(queryKey)\n      ? queryKey\n      : [queryKey]\n    const queryHash = stableStringify(arrayQueryKey)\n    arrayQueryKey = JSON.parse(queryHash)\n    return [queryHash, arrayQueryKey]\n  } catch {\n    throw new Error('A valid query key is required!')\n  }\n}\n\nexport const DEFAULT_CONFIG: ReactQueryConfig = {\n  shared: {\n    suspense: false,\n  },\n  queries: {\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    useErrorBoundary: false,\n  },\n  mutations: {\n    throwOnError: false,\n    useErrorBoundary: false,\n  },\n}\n\nexport const defaultConfigRef: ReactQueryConfigRef = {\n  current: DEFAULT_CONFIG,\n}\n","import { uid, isServer, isDocumentVisible, Console } from './utils'\nimport { Query, QueryState } from './query'\nimport { BaseQueryConfig } from './types'\n\n// TYPES\n\nexport type OnStateUpdateFunction<TResult, TError> = (\n  state: QueryState<TResult, TError>\n) => void\n\n// CLASS\n\nexport class QueryInstance<TResult, TError> {\n  id: number\n  config: BaseQueryConfig<TResult, TError>\n  onStateUpdate?: OnStateUpdateFunction<TResult, TError>\n\n  private query: Query<TResult, TError>\n  private refetchIntervalId?: number\n\n  constructor(\n    query: Query<TResult, TError>,\n    onStateUpdate?: OnStateUpdateFunction<TResult, TError>\n  ) {\n    this.id = uid()\n    this.onStateUpdate = onStateUpdate\n    this.query = query\n    this.config = {}\n  }\n\n  clearInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  updateConfig(config: BaseQueryConfig<TResult, TError>): void {\n    const oldConfig = this.config\n\n    // Update the config\n    this.config = config\n\n    if (!isServer) {\n      if (oldConfig?.refetchInterval === config.refetchInterval) {\n        return\n      }\n\n      this.query.clearIntervals()\n\n      const minInterval = Math.min(\n        ...this.query.instances.map(d => d.config.refetchInterval || Infinity)\n      )\n\n      if (\n        !this.refetchIntervalId &&\n        minInterval > 0 &&\n        minInterval < Infinity\n      ) {\n        this.refetchIntervalId = setInterval(() => {\n          if (\n            this.query.instances.some(_ => this.config.enabled) &&\n            (isDocumentVisible() ||\n              this.query.instances.some(\n                _ => this.config.refetchIntervalInBackground\n              ))\n          ) {\n            this.query.fetch()\n          }\n        }, minInterval)\n      }\n    }\n  }\n\n  async run(): Promise<void> {\n    try {\n      // Perform the refetch for this query if necessary\n      if (\n        this.query.config.enabled && // Don't auto refetch if disabled\n        !this.query.wasSuspended && // Don't double refetch for suspense\n        this.query.state.isStale && // Only refetch if stale\n        (this.query.config.refetchOnMount || this.query.instances.length === 1)\n      ) {\n        await this.query.fetch()\n      }\n\n      this.query.wasSuspended = false\n    } catch (error) {\n      Console.error(error)\n    }\n  }\n\n  unsubscribe(): void {\n    this.query.instances = this.query.instances.filter(d => d.id !== this.id)\n\n    if (!this.query.instances.length) {\n      this.clearInterval()\n      this.query.cancel()\n\n      if (!isServer) {\n        // Schedule garbage collection\n        this.query.scheduleGarbageCollection()\n      }\n    }\n  }\n}\n","import {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  noop,\n  Console,\n  getStatusProps,\n  shallowEqual,\n  Updater,\n} from './utils'\nimport { QueryInstance, OnStateUpdateFunction } from './queryInstance'\nimport {\n  ArrayQueryKey,\n  InfiniteQueryConfig,\n  InitialDataFunction,\n  IsFetchingMoreValue,\n  QueryConfig,\n  QueryFunction,\n  QueryStatus,\n} from './types'\nimport { QueryCache } from './queryCache'\n\n// TYPES\n\ninterface QueryInitConfig<TResult, TError> {\n  queryCache: QueryCache\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  notifyGlobalListeners: (query: Query<TResult, TError>) => void\n}\n\nexport interface QueryState<TResult, TError> {\n  canFetchMore?: boolean\n  data?: TResult\n  error: TError | null\n  failureCount: number\n  isError: boolean\n  isFetching: boolean\n  isFetchingMore?: IsFetchingMoreValue\n  isIdle: boolean\n  isLoading: boolean\n  isStale: boolean\n  isSuccess: boolean\n  markedForGarbageCollection: boolean\n  status: QueryStatus\n  throwInErrorBoundary?: boolean\n  updatedAt: number\n}\n\ninterface FetchOptions {\n  fetchMore?: FetchMoreOptions\n}\n\nexport interface FetchMoreOptions {\n  fetchMoreVariable?: unknown\n  previous: boolean\n}\n\nenum ActionType {\n  Failed = 'Failed',\n  MarkStale = 'MarkStale',\n  MarkGC = 'MarkGC',\n  Fetch = 'Fetch',\n  Success = 'Success',\n  Error = 'Error',\n  SetState = 'SetState',\n}\n\ninterface FailedAction {\n  type: ActionType.Failed\n}\n\ninterface MarkStaleAction {\n  type: ActionType.MarkStale\n}\n\ninterface MarkGCAction {\n  type: ActionType.MarkGC\n}\n\ninterface FetchAction {\n  type: ActionType.Fetch\n}\n\ninterface SuccessAction<TResult> {\n  type: ActionType.Success\n  updater: Updater<TResult | undefined, TResult>\n  isStale: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: ActionType.Error\n  cancelled: boolean\n  error: TError\n}\n\ninterface SetStateAction<TResult, TError> {\n  type: ActionType.SetState\n  updater: Updater<QueryState<TResult, TError>, QueryState<TResult, TError>>\n}\n\ntype Action<TResult, TError> =\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | MarkGCAction\n  | MarkStaleAction\n  | SetStateAction<TResult, TError>\n  | SuccessAction<TResult>\n\n// CLASS\n\nexport class Query<TResult, TError> {\n  queryCache: QueryCache\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  instances: QueryInstance<TResult, TError>[]\n  state: QueryState<TResult, TError>\n  fallbackInstance?: QueryInstance<TResult, TError>\n  wasSuspended?: boolean\n  shouldContinueRetryOnFocus?: boolean\n  promise?: Promise<TResult | undefined>\n\n  private fetchMoreVariable?: unknown\n  private pageVariables?: ArrayQueryKey[]\n  private cacheTimeout?: number\n  private retryTimeout?: number\n  private staleTimeout?: number\n  private cancelPromises?: () => void\n  private cancelled?: typeof cancelledError | null\n  private notifyGlobalListeners: (query: Query<TResult, TError>) => void\n\n  constructor(init: QueryInitConfig<TResult, TError>) {\n    this.config = init.config\n    this.queryCache = init.queryCache\n    this.queryKey = init.queryKey\n    this.queryHash = init.queryHash\n    this.notifyGlobalListeners = init.notifyGlobalListeners\n    this.instances = []\n    this.state = getDefaultState(init.config)\n\n    if (init.config.infinite) {\n      const infiniteConfig = init.config as InfiniteQueryConfig<TResult, TError>\n      const infiniteData = (this.state.data as unknown) as TResult[] | undefined\n\n      if (\n        typeof infiniteData !== 'undefined' &&\n        typeof this.state.canFetchMore === 'undefined'\n      ) {\n        this.fetchMoreVariable = infiniteConfig.getFetchMore(\n          infiniteData[infiniteData.length - 1],\n          infiniteData\n        )\n        this.state.canFetchMore = this.fetchMoreVariable !== false\n      }\n\n      // Here we seed the pageVariabes for the query\n      if (!this.pageVariables) {\n        this.pageVariables = [[...this.queryKey]]\n      }\n    }\n  }\n\n  private dispatch(action: Action<TResult, TError>): void {\n    const newState = queryReducer(this.state, action)\n\n    // Only update state if something has changed\n    if (!shallowEqual(this.state, newState)) {\n      this.state = newState\n      this.instances.forEach(d => d.onStateUpdate?.(this.state))\n      this.notifyGlobalListeners(this)\n    }\n  }\n\n  scheduleStaleTimeout(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearStaleTimeout()\n\n    if (this.state.isStale) {\n      return\n    }\n\n    if (this.config.staleTime === Infinity) {\n      return\n    }\n\n    this.staleTimeout = setTimeout(() => {\n      this.invalidate()\n    }, this.config.staleTime)\n  }\n\n  invalidate(): void {\n    this.clearStaleTimeout()\n\n    if (!this.queryCache.queries[this.queryHash]) {\n      return\n    }\n\n    if (this.state.isStale) {\n      return\n    }\n\n    this.dispatch({ type: ActionType.MarkStale })\n  }\n\n  scheduleGarbageCollection(): void {\n    this.clearCacheTimeout()\n\n    if (!this.queryCache.queries[this.queryHash]) {\n      return\n    }\n\n    if (this.config.cacheTime === Infinity) {\n      return\n    }\n\n    this.dispatch({ type: ActionType.MarkGC })\n\n    this.cacheTimeout = setTimeout(\n      () => {\n        this.queryCache.removeQueries(\n          d =>\n            d.state.markedForGarbageCollection && d.queryHash === this.queryHash\n        )\n      },\n      typeof this.state.data === 'undefined' &&\n        this.state.status !== QueryStatus.Error\n        ? 0\n        : this.config.cacheTime\n    )\n  }\n\n  async refetch(): Promise<void> {\n    try {\n      await this.fetch()\n    } catch (error) {\n      Console.error(error)\n    }\n  }\n\n  heal(): void {\n    // Stop the query from being garbage collected\n    this.clearCacheTimeout()\n\n    // Mark the query as not cancelled\n    this.cancelled = null\n  }\n\n  cancel(): void {\n    this.cancelled = cancelledError\n\n    if (this.cancelPromises) {\n      this.cancelPromises()\n    }\n\n    delete this.promise\n  }\n\n  clearIntervals(): void {\n    this.instances.forEach(instance => {\n      instance.clearInterval()\n    })\n  }\n\n  private clearStaleTimeout() {\n    if (this.staleTimeout) {\n      clearTimeout(this.staleTimeout)\n      this.staleTimeout = undefined\n    }\n  }\n\n  private clearCacheTimeout() {\n    if (this.cacheTimeout) {\n      clearTimeout(this.cacheTimeout)\n      this.cacheTimeout = undefined\n    }\n  }\n\n  private clearRetryTimeout() {\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout)\n      this.retryTimeout = undefined\n    }\n  }\n\n  private setState(\n    updater: Updater<QueryState<TResult, TError>, QueryState<TResult, TError>>\n  ): void {\n    this.dispatch({ type: ActionType.SetState, updater })\n  }\n\n  setData(updater: Updater<TResult | undefined, TResult>): void {\n    const isStale = this.config.staleTime === 0\n    // Set data and mark it as cached\n    this.dispatch({\n      type: ActionType.Success,\n      updater,\n      isStale,\n    })\n\n    if (!isStale) {\n      // Schedule a fresh invalidation!\n      this.scheduleStaleTimeout()\n    }\n  }\n\n  clear(): void {\n    this.clearStaleTimeout()\n    this.clearCacheTimeout()\n    this.clearRetryTimeout()\n    this.clearIntervals()\n    this.cancel()\n    delete this.queryCache.queries[this.queryHash]\n    this.notifyGlobalListeners(this)\n  }\n\n  subscribe(\n    onStateUpdate?: OnStateUpdateFunction<TResult, TError>\n  ): QueryInstance<TResult, TError> {\n    const instance = new QueryInstance(this, onStateUpdate)\n    this.instances.push(instance)\n    this.heal()\n    return instance\n  }\n\n  // Set up the core fetcher function\n  private async tryFetchData(\n    fn: QueryFunction<TResult>,\n    args: ArrayQueryKey\n  ): Promise<TResult> {\n    try {\n      // Perform the query\n      const promiseOrValue = fn(...this.config.queryFnParamsFilter!(args))\n\n      this.cancelPromises = () => (promiseOrValue as any)?.cancel?.()\n\n      const data = await promiseOrValue\n      delete this.shouldContinueRetryOnFocus\n\n      delete this.cancelPromises\n      if (this.cancelled) throw this.cancelled\n\n      return data\n    } catch (error) {\n      delete this.cancelPromises\n      if (this.cancelled) throw this.cancelled\n\n      // Do we need to retry the request?\n      if (\n        this.config.retry === true ||\n        this.state.failureCount < this.config.retry! ||\n        (typeof this.config.retry === 'function' &&\n          this.config.retry(this.state.failureCount, error))\n      ) {\n        // If we retry, increase the failureCount\n        this.dispatch({ type: ActionType.Failed })\n\n        // Only retry if the document is visible\n        if (!isDocumentVisible()) {\n          // set this flag to continue retries on focus\n          this.shouldContinueRetryOnFocus = true\n          // Resolve a\n          return new Promise(noop)\n        }\n\n        delete this.shouldContinueRetryOnFocus\n\n        // Determine the retryDelay\n        const delay = functionalUpdate(\n          this.config.retryDelay,\n          this.state.failureCount\n        )\n\n        // Return a new promise with the retry\n        return await new Promise((resolve, reject) => {\n          // Keep track of the retry timeout\n          this.retryTimeout = setTimeout(async () => {\n            if (this.cancelled) return reject(this.cancelled)\n\n            try {\n              const data = await this.tryFetchData(fn, args)\n              if (this.cancelled) return reject(this.cancelled)\n              resolve(data)\n            } catch (error) {\n              if (this.cancelled) return reject(this.cancelled)\n              reject(error)\n            }\n          }, delay)\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async fetch(options?: FetchOptions): Promise<TResult | undefined> {\n    let queryFn = this.config.queryFn\n\n    if (!queryFn) {\n      return\n    }\n\n    // If we are already fetching, return current promise\n    if (this.promise) {\n      return this.promise\n    }\n\n    if (this.config.infinite) {\n      const infiniteConfig = this.config as InfiniteQueryConfig<TResult, TError>\n      const infiniteData = (this.state.data as unknown) as TResult[] | undefined\n      const fetchMore = options?.fetchMore\n\n      const originalQueryFn = queryFn\n\n      queryFn = async () => {\n        const data: TResult[] = []\n        const pageVariables = this.pageVariables ? [...this.pageVariables] : []\n        const rebuiltPageVariables: ArrayQueryKey[] = []\n\n        do {\n          const args = pageVariables.shift()!\n\n          if (!data.length) {\n            // the first page query doesn't need to be rebuilt\n            data.push(await originalQueryFn(...args))\n            rebuiltPageVariables.push(args)\n          } else {\n            // get an up-to-date cursor based on the previous data set\n\n            const nextCursor = infiniteConfig.getFetchMore(\n              data[data.length - 1],\n              data\n            )\n\n            // break early if there's no next cursor\n            // otherwise we'll start from the beginning\n            // which will cause unwanted duplication\n            if (!nextCursor) {\n              break\n            }\n\n            const pageArgs = [\n              // remove the last argument (the previously saved cursor)\n              ...args.slice(0, -1),\n              nextCursor,\n            ] as ArrayQueryKey\n\n            data.push(await originalQueryFn(...pageArgs))\n            rebuiltPageVariables.push(pageArgs)\n          }\n        } while (pageVariables.length)\n\n        this.fetchMoreVariable = infiniteConfig.getFetchMore(\n          data[data.length - 1],\n          data\n        )\n        this.state.canFetchMore = this.fetchMoreVariable !== false\n        this.pageVariables = rebuiltPageVariables\n\n        return (data as unknown) as TResult\n      }\n\n      if (fetchMore) {\n        queryFn = async (...args: ArrayQueryKey) => {\n          try {\n            const { fetchMoreVariable, previous } = fetchMore\n\n            this.setState(old => ({\n              ...old,\n              isFetchingMore: previous ? 'previous' : 'next',\n            }))\n\n            const newArgs = [...args, fetchMoreVariable] as ArrayQueryKey\n\n            if (this.pageVariables) {\n              this.pageVariables[previous ? 'unshift' : 'push'](newArgs)\n            } else {\n              this.pageVariables = [newArgs]\n            }\n\n            const newData = await originalQueryFn(...newArgs)\n\n            let data\n\n            if (!infiniteData) {\n              data = [newData]\n            } else if (previous) {\n              data = [newData, ...infiniteData]\n            } else {\n              data = [...infiniteData, newData]\n            }\n\n            this.fetchMoreVariable = infiniteConfig.getFetchMore(newData, data)\n            this.state.canFetchMore = this.fetchMoreVariable !== false\n\n            return (data as unknown) as TResult\n          } finally {\n            this.setState(old => ({\n              ...old,\n              isFetchingMore: false,\n            }))\n          }\n        }\n      }\n    }\n\n    this.promise = (async () => {\n      // If there are any retries pending for this query, kill them\n      this.cancelled = null\n\n      const getCallbackInstances = () => {\n        const callbackInstances = [...this.instances]\n\n        if (this.wasSuspended && this.fallbackInstance) {\n          callbackInstances.unshift(this.fallbackInstance)\n        }\n        return callbackInstances\n      }\n\n      try {\n        // Set up the query refreshing state\n        this.dispatch({ type: ActionType.Fetch })\n\n        // Try to get the data\n        const data = await this.tryFetchData(queryFn!, this.queryKey)\n\n        this.setData(old => (this.config.isDataEqual!(old, data) ? old! : data))\n\n        getCallbackInstances().forEach(instance => {\n          instance.config.onSuccess?.(this.state.data!)\n        })\n\n        getCallbackInstances().forEach(instance =>\n          instance.config.onSettled?.(this.state.data, null)\n        )\n\n        delete this.promise\n\n        return data\n      } catch (error) {\n        this.dispatch({\n          type: ActionType.Error,\n          cancelled: error === this.cancelled,\n          error,\n        })\n\n        delete this.promise\n\n        if (error !== this.cancelled) {\n          getCallbackInstances().forEach(instance =>\n            instance.config.onError?.(error)\n          )\n\n          getCallbackInstances().forEach(instance =>\n            instance.config.onSettled?.(undefined, error)\n          )\n\n          throw error\n        }\n\n        return\n      }\n    })()\n\n    return this.promise\n  }\n\n  fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ): Promise<TResult | undefined> {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable ?? this.fetchMoreVariable,\n        previous: options?.previous || false,\n      },\n    })\n  }\n}\n\nfunction getDefaultState<TResult, TError>(\n  config: QueryConfig<TResult, TError>\n): QueryState<TResult, TError> {\n  const initialData =\n    typeof config.initialData === 'function'\n      ? (config.initialData as InitialDataFunction<TResult>)()\n      : config.initialData\n\n  const hasInitialData = typeof initialData !== 'undefined'\n\n  const isStale =\n    !config.enabled ||\n    (typeof config.initialStale === 'function'\n      ? config.initialStale()\n      : config.initialStale ?? !hasInitialData)\n\n  const initialStatus = hasInitialData\n    ? QueryStatus.Success\n    : config.enabled\n    ? QueryStatus.Loading\n    : QueryStatus.Idle\n\n  return {\n    ...getStatusProps(initialStatus),\n    error: null,\n    isFetching: initialStatus === QueryStatus.Loading,\n    failureCount: 0,\n    isStale,\n    markedForGarbageCollection: false,\n    data: initialData,\n    updatedAt: hasInitialData ? Date.now() : 0,\n  }\n}\n\nexport function queryReducer<TResult, TError>(\n  state: QueryState<TResult, TError>,\n  action: Action<TResult, TError>\n): QueryState<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Failed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case ActionType.MarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case ActionType.MarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case ActionType.Fetch:\n      const status =\n        typeof state.data !== 'undefined'\n          ? QueryStatus.Success\n          : QueryStatus.Loading\n      return {\n        ...state,\n        ...getStatusProps(status),\n        isFetching: true,\n        failureCount: 0,\n      }\n    case ActionType.Success:\n      return {\n        ...state,\n        ...getStatusProps(QueryStatus.Success),\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: action.isStale,\n        isFetching: false,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case ActionType.Error:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          ...getStatusProps(QueryStatus.Error),\n          error: action.error,\n          throwInErrorBoundary: true,\n        }),\n      }\n    case ActionType.SetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      return state\n  }\n}\n","import {\n  isServer,\n  getQueryArgs,\n  deepIncludes,\n  Console,\n  isObject,\n  Updater,\n} from './utils'\nimport { defaultConfigRef, ReactQueryConfigRef } from './config'\nimport { Query } from './query'\nimport {\n  QueryConfig,\n  QueryKey,\n  QueryKeyWithoutObject,\n  ReactQueryConfig,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObjectAndArray,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from './types'\nimport { QueryInstance } from './queryInstance'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  frozen?: boolean\n  defaultConfig?: ReactQueryConfig\n}\n\ninterface ClearOptions {\n  notify?: boolean\n}\n\ninterface PrefetchQueryOptions {\n  force?: boolean\n  throwOnError?: boolean\n}\n\ninterface InvalidateQueriesOptions extends QueryPredicateOptions {\n  refetchActive?: boolean\n  refetchInactive?: boolean\n  throwOnError?: boolean\n}\n\ninterface QueryPredicateOptions {\n  exact?: boolean\n}\n\ntype QueryPredicate = QueryKey | QueryPredicateFn | true\n\ntype QueryPredicateFn = (query: Query<unknown, unknown>) => boolean\n\nexport interface PrefetchQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, TKey>\n  config?: QueryConfig<TResult, TError>\n  options?: PrefetchQueryOptions\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (\n  cache: QueryCache,\n  query?: Query<unknown, unknown>\n) => void\n\n// CLASS\n\nexport class QueryCache {\n  queries: QueryHashMap\n  isFetching: number\n\n  private config: QueryCacheConfig\n  private configRef: ReactQueryConfigRef\n  private globalListeners: QueryCacheListener[]\n\n  constructor(config?: QueryCacheConfig) {\n    this.config = config || {}\n\n    // A frozen cache does not add new queries to the cache\n    this.globalListeners = []\n\n    this.configRef = this.config.defaultConfig\n      ? {\n          current: {\n            shared: {\n              ...defaultConfigRef.current.shared,\n              ...this.config.defaultConfig.shared,\n            },\n            queries: {\n              ...defaultConfigRef.current.queries,\n              ...this.config.defaultConfig.queries,\n            },\n            mutations: {\n              ...defaultConfigRef.current.mutations,\n              ...this.config.defaultConfig.mutations,\n            },\n          },\n        }\n      : defaultConfigRef\n\n    this.queries = {}\n    this.isFetching = 0\n  }\n\n  private notifyGlobalListeners(query?: Query<any, any>) {\n    this.isFetching = Object.values(this.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    this.globalListeners.forEach(d => d(queryCache, query))\n  }\n\n  subscribe(listener: QueryCacheListener): () => void {\n    this.globalListeners.push(listener)\n    return () => {\n      this.globalListeners.splice(this.globalListeners.indexOf(listener), 1)\n    }\n  }\n\n  clear(options?: ClearOptions): void {\n    Object.values(this.queries).forEach(query => query.clear())\n    this.queries = {}\n    if (options?.notify) {\n      this.notifyGlobalListeners()\n    }\n  }\n\n  getQueries<TResult = unknown, TError = unknown>(\n    predicate: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): Query<TResult, TError>[] {\n    if (predicate === true) {\n      return Object.values(this.queries)\n    }\n\n    let predicateFn: QueryPredicateFn\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate as QueryPredicateFn\n    } else {\n      const [queryHash, queryKey] = this.configRef.current.queries!\n        .queryKeySerializerFn!(predicate)\n\n      predicateFn = d =>\n        options?.exact\n          ? d.queryHash === queryHash\n          : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(this.queries).filter(predicateFn)\n  }\n\n  getQuery<TResult, TError = unknown>(\n    predicate: QueryPredicate\n  ): Query<TResult, TError> | undefined {\n    return this.getQueries<TResult, TError>(predicate, { exact: true })[0]\n  }\n\n  getQueryData<TResult>(predicate: QueryPredicate): TResult | undefined {\n    return this.getQuery<TResult>(predicate)?.state.data\n  }\n\n  removeQueries(\n    predicate: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => query.clear())\n  }\n\n  cancelQueries(\n    predicate: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => query.cancel())\n  }\n\n  async invalidateQueries(\n    predicate: QueryPredicate,\n    options?: InvalidateQueriesOptions\n  ): Promise<void> {\n    const { refetchActive = true, refetchInactive = false, throwOnError } =\n      options || {}\n\n    try {\n      await Promise.all(\n        this.getQueries(predicate, options).map(query => {\n          if (query.instances.length) {\n            if (\n              refetchActive &&\n              query.instances.some(instance => instance.config.enabled)\n            ) {\n              return query.fetch()\n            }\n          } else {\n            if (refetchInactive) {\n              return query.fetch()\n            }\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  resetErrorBoundaries(): void {\n    this.getQueries(true).forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  buildQuery<TResult, TError = unknown>(\n    userQueryKey: QueryKey,\n    queryConfig: QueryConfig<TResult, TError> = {}\n  ): Query<TResult, TError> {\n    const config = {\n      ...this.configRef.current.shared!,\n      ...this.configRef.current.queries!,\n      ...queryConfig,\n    } as QueryConfig<TResult, TError>\n\n    const [queryHash, queryKey] = config.queryKeySerializerFn!(userQueryKey)\n\n    let query\n\n    if (this.queries[queryHash]) {\n      query = this.queries[queryHash] as Query<TResult, TError>\n      query.config = config\n    }\n\n    if (!query) {\n      query = new Query<TResult, TError>({\n        queryCache,\n        queryKey,\n        queryHash,\n        config,\n        notifyGlobalListeners: query => {\n          this.notifyGlobalListeners(query)\n        },\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (!this.config.frozen) {\n        this.queries[queryHash] = query\n\n        if (isServer) {\n          this.notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            this.notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled,\n      },\n    } as QueryInstance<TResult, TError>\n\n    return query\n  }\n\n  // Parameter syntax with optional prefetch options\n  async prefetchQuery<TResult, TError, TKey extends QueryKeyWithoutObject>(\n    queryKey: TKey,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with config and optional prefetch options\n  async prefetchQuery<TResult, TError, TKey extends QueryKeyWithoutObject>(\n    queryKey: TKey,\n    config: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function and optional prefetch options\n  async prefetchQuery<\n    TResult,\n    TError,\n    TKey extends QueryKeyWithoutObjectAndArray\n  >(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, [TKey]>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult, TError, TKey extends TupleQueryKey>(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, TKey>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function, config and optional prefetch options\n  async prefetchQuery<\n    TResult,\n    TError,\n    TKey extends QueryKeyWithoutObjectAndArray\n  >(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, [TKey]>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult, TError, TKey extends TupleQueryKey>(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, TKey>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Object syntax\n  async prefetchQuery<TResult, TError, TKey extends QueryKeyWithoutArray>(\n    config: PrefetchQueryObjectConfig<TResult, TError, [TKey]>\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult, TError, TKey extends TupleQueryKey>(\n    config: PrefetchQueryObjectConfig<TResult, TError, TKey>\n  ): Promise<TResult | undefined>\n\n  // Implementation\n  async prefetchQuery<TResult, TError>(\n    ...args: any[]\n  ): Promise<TResult | undefined> {\n    if (\n      isObject(args[1]) &&\n      (args[1].hasOwnProperty('throwOnError') ||\n        args[1].hasOwnProperty('force'))\n    ) {\n      args[3] = args[1]\n      args[1] = undefined\n      args[2] = undefined\n    }\n\n    const [queryKey, config, options] = getQueryArgs<\n      TResult,\n      TError,\n      PrefetchQueryOptions | undefined\n    >(args)\n    // https://github.com/tannerlinsley/react-query/issues/652\n    const configWithoutRetry = { retry: false, ...config }\n\n    try {\n      const query = this.buildQuery<TResult, TError>(\n        queryKey,\n        configWithoutRetry\n      )\n      if (options?.force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (options?.throwOnError) {\n        throw err\n      }\n      Console.error(err)\n      return\n    }\n  }\n\n  setQueryData<TResult, TError = unknown>(\n    queryKey: QueryKey,\n    updater: Updater<TResult | undefined, TResult>,\n    config: QueryConfig<TResult, TError> = {}\n  ) {\n    let query = this.getQuery<TResult, TError>(queryKey)\n\n    if (!query) {\n      query = this.buildQuery<TResult, TError>(queryKey, config)\n    }\n\n    query.setData(updater)\n  }\n}\n\nexport const queryCache = makeQueryCache({ frozen: isServer })\n\nexport const queryCaches = [queryCache]\n\nexport function makeQueryCache(config?: QueryCacheConfig) {\n  return new QueryCache(config)\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\ntype FocusHandler = () => void\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus: FocusHandler = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (!query.instances.some(instance => instance.config.enabled)) {\n            return false\n          }\n\n          if (!query.state.isStale) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n          }\n\n          return Boolean(query.config.refetchOnWindowFocus)\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler: (() => void) | void\n\nexport function setFocusHandler(callback: (callback: FocusHandler) => void) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler((handleFocus: FocusHandler) => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n  return\n})\n","import React from 'react'\n\nimport {\n  queryCache as defaultQueryCache,\n  queryCaches,\n  makeQueryCache,\n} from '../core'\nimport { QueryCache } from '../core/queryCache'\n\nexport const queryCacheContext = React.createContext(defaultQueryCache)\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport interface ReactQueryCacheProviderProps {\n  queryCache?: QueryCache\n}\n\nexport const ReactQueryCacheProvider: React.FC<ReactQueryCacheProviderProps> = ({\n  queryCache,\n  children,\n}) => {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear({ notify: false })\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { DEFAULT_CONFIG, defaultConfigRef } from '../core/config'\nimport { ReactQueryConfig } from '../core/types'\n\nconst configContext = React.createContext<ReactQueryConfig | undefined>(\n  undefined\n)\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport interface ReactQueryProviderConfig extends ReactQueryConfig {}\n\nexport interface ReactQueryConfigProviderProps {\n  config: ReactQueryProviderConfig\n}\n\nexport const ReactQueryConfigProvider: React.FC<ReactQueryConfigProviderProps> = ({\n  config,\n  children,\n}) => {\n  const configContextValueOrDefault = useConfigContext()\n  const configContextValue = React.useContext(configContext)\n\n  const newConfig = React.useMemo<ReactQueryConfig>(() => {\n    const { shared = {}, queries = {}, mutations = {} } = config\n    const {\n      shared: contextShared = {},\n      queries: contextQueries = {},\n      mutations: contextMutations = {},\n    } = configContextValueOrDefault\n\n    return {\n      shared: {\n        ...contextShared,\n        ...shared,\n      },\n      queries: {\n        ...contextQueries,\n        ...queries,\n      },\n      mutations: {\n        ...contextMutations,\n        ...mutations,\n      },\n    }\n  }, [config, configContextValueOrDefault])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = {\n        ...(configContextValueOrDefault || DEFAULT_CONFIG),\n      }\n    }\n  }, [configContextValueOrDefault])\n\n  // If this is the outermost provider, overwrite the shared default config\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { useConfigContext } from './ReactQueryConfigProvider'\nimport { useGetLatest, useMountedCallback } from './utils'\nimport { Console, uid, getStatusProps } from '../core/utils'\nimport {\n  QueryStatus,\n  MutationResultPair,\n  MutationFunction,\n  MutationConfig,\n  MutateConfig,\n} from '../core/types'\n\n// TYPES\n\ntype Reducer<S, A> = (prevState: S, action: A) => S\n\ninterface State<TResult, TError> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n}\n\nenum ActionType {\n  Reset = 'Reset',\n  Loading = 'Loading',\n  Resolve = 'Resolve',\n  Reject = 'Reject',\n}\n\ninterface ResetAction {\n  type: ActionType.Reset\n}\n\ninterface LoadingAction {\n  type: ActionType.Loading\n}\n\ninterface ResolveAction<TResult> {\n  type: ActionType.Resolve\n  data: TResult\n}\n\ninterface RejectAction<TError> {\n  type: ActionType.Reject\n  error: TError\n}\n\ntype Action<TResult, TError> =\n  | ResetAction\n  | LoadingAction\n  | ResolveAction<TResult>\n  | RejectAction<TError>\n\n// HOOK\n\nconst getDefaultState = (): State<any, any> => ({\n  ...getStatusProps(QueryStatus.Idle),\n  data: undefined,\n  error: null,\n})\n\nfunction mutationReducer<TResult, TError>(\n  state: State<TResult, TError>,\n  action: Action<TResult, TError>\n): State<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Reset:\n      return getDefaultState()\n    case ActionType.Loading:\n      return {\n        ...getStatusProps(QueryStatus.Loading),\n        data: undefined,\n        error: null,\n      }\n    case ActionType.Resolve:\n      return {\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n      }\n    case ActionType.Reject:\n      return {\n        ...getStatusProps(QueryStatus.Error),\n        data: undefined,\n        error: action.error,\n      }\n    default:\n      return state\n  }\n}\n\nexport function useMutation<\n  TResult,\n  TError = unknown,\n  TVariables = undefined,\n  TSnapshot = unknown\n>(\n  mutationFn: MutationFunction<TResult, TVariables>,\n  config: MutationConfig<TResult, TError, TVariables, TSnapshot> = {}\n): MutationResultPair<TResult, TError, TVariables, TSnapshot> {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer as Reducer<State<TResult, TError>, Action<TResult, TError>>,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const contextConfig = useConfigContext()\n\n  const getConfig = useGetLatest({\n    ...contextConfig.shared,\n    ...contextConfig.mutations,\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef<number>()\n\n  const mutate = React.useCallback(\n    async (\n      variables?: TVariables,\n      mutateConfig: MutateConfig<TResult, TError, TVariables, TSnapshot> = {}\n    ): Promise<TResult | undefined> => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      let snapshotValue: TSnapshot | undefined\n\n      try {\n        dispatch({ type: ActionType.Loading })\n        snapshotValue = (await config.onMutate?.(variables!)) as TSnapshot\n\n        const data = await getMutationFn()(variables!)\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Resolve, data })\n        }\n\n        await config.onSuccess?.(data, variables!)\n        await mutateConfig.onSuccess?.(data, variables!)\n        await config.onSettled?.(data, null, variables!)\n        await mutateConfig.onSettled?.(data, null, variables!)\n\n        return data\n      } catch (error) {\n        Console.error(error)\n        await config.onError?.(error, variables!, snapshotValue!)\n        await mutateConfig.onError?.(error, variables!, snapshotValue!)\n        await config.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue as TSnapshot\n        )\n        await mutateConfig.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue\n        )\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Reject, error })\n        }\n\n        if (mutateConfig.throwOnError ?? config.throwOnError) {\n          throw error\n        }\n\n        return\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => {\n    dispatch({ type: ActionType.Reset })\n  }, [dispatch])\n\n  React.useEffect(() => {\n    const { suspense, useErrorBoundary } = getConfig()\n\n    if ((useErrorBoundary ?? suspense) && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [mutate, { ...state, reset }]\n}\n","import React from 'react'\n\nimport { uid, isServer } from '../core/utils'\nimport { QueryResultBase, QueryStatus } from '../core/types'\n\nexport function useUid(): number {\n  const ref = React.useRef(0)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function useGetLatest<T>(obj: T): () => T {\n  const ref = React.useRef<T>(obj)\n  ref.current = obj\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function useMountedCallback<T extends Function>(callback: T): T {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => {\n      mounted.current = false\n    }\n  }, [])\n\n  return (React.useCallback(\n    (...args: any[]) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  ) as any) as T\n}\n\nexport function useRerenderer() {\n  const rerender = useMountedCallback(React.useState<unknown>()[1])\n  return React.useCallback(() => rerender({}), [rerender])\n}\n\nexport function handleSuspense(result: QueryResultBase<any, any>) {\n  const { error, query } = result\n  const { config, state } = query\n\n  if (config.suspense || config.useErrorBoundary) {\n    if (state.status === QueryStatus.Error && state.throwInErrorBoundary) {\n      throw error\n    }\n\n    if (\n      config.suspense &&\n      state.status !== QueryStatus.Success &&\n      config.enabled\n    ) {\n      query.wasSuspended = true\n      throw query.fetch()\n    }\n  }\n}\n","import React from 'react'\n\nimport { useRerenderer, useGetLatest } from './utils'\nimport { useQueryCache } from './ReactQueryCacheProvider'\n\nexport function useIsFetching(): number {\n  const queryCache = useQueryCache()\n  const rerender = useRerenderer()\n  const isFetching = queryCache.isFetching\n\n  const getIsFetching = useGetLatest(isFetching)\n\n  React.useEffect(\n    () =>\n      queryCache.subscribe(newCache => {\n        if (getIsFetching() !== newCache.isFetching) {\n          rerender()\n        }\n      }),\n    [getIsFetching, queryCache, rerender]\n  )\n\n  return isFetching\n}\n","import React from 'react'\n\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useRerenderer } from './utils'\nimport { QueryInstance } from '../core/queryInstance'\nimport { QueryConfig, QueryKey, QueryResultBase } from '../core/types'\n\nexport function useBaseQuery<TResult, TError>(\n  queryKey: QueryKey,\n  config: QueryConfig<TResult, TError> = {}\n): QueryResultBase<TResult, TError> {\n  // Make a rerender function\n  const rerender = useRerenderer()\n\n  // Get the query cache\n  const queryCache = useQueryCache()\n\n  // Build the query for use\n  const query = queryCache.buildQuery<TResult, TError>(queryKey, config)\n  const state = query.state\n\n  // Create a query instance ref\n  const instanceRef = React.useRef<QueryInstance<TResult, TError>>()\n\n  // Subscribe to the query when the subscribe function changes\n  React.useEffect(() => {\n    const instance = query.subscribe(() => {\n      rerender()\n    })\n\n    instanceRef.current = instance\n\n    // Unsubscribe when things change\n    return () => instance.unsubscribe()\n  }, [query, rerender])\n\n  // Always update the config\n  React.useEffect(() => {\n    instanceRef.current?.updateConfig(config)\n  })\n\n  const enabledBool = Boolean(config.enabled)\n\n  // Run the instance when the query or enabled change\n  React.useEffect(() => {\n    if (enabledBool && query) {\n      // Just for change detection\n    }\n    instanceRef.current?.run()\n  }, [enabledBool, query])\n\n  const clear = React.useMemo(() => query.clear.bind(query), [query])\n  const refetch = React.useMemo(() => query.refetch.bind(query), [query])\n\n  return {\n    clear,\n    error: state.error,\n    failureCount: state.failureCount,\n    isError: state.isError,\n    isFetching: state.isFetching,\n    isIdle: state.isIdle,\n    isLoading: state.isLoading,\n    isStale: state.isStale,\n    isSuccess: state.isSuccess,\n    query,\n    refetch,\n    status: state.status,\n    updatedAt: state.updatedAt,\n  }\n}\n","import { getQueryArgs } from '../core/utils'\nimport { useConfigContext } from './ReactQueryConfigProvider'\nimport { QueryConfig, QueryKey } from '../core/types'\n\nexport function useQueryArgs<TResult, TError, TOptions = undefined>(\n  args: any[]\n): [QueryKey, QueryConfig<TResult, TError>, TOptions] {\n  const configContext = useConfigContext()\n\n  const [queryKey, config, options] = getQueryArgs<TResult, TError, TOptions>(\n    args\n  )\n\n  // Build the final config\n  const configWithContext = {\n    ...configContext.shared,\n    ...configContext.queries,\n    ...config,\n  } as QueryConfig<TResult, TError>\n\n  return [queryKey, configWithContext, options]\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { handleSuspense } from './utils'\nimport {\n  QueryConfig,\n  QueryKey,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObject,\n  QueryKeyWithoutObjectAndArray,\n  QueryResult,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from '../core/types'\nimport { useQueryArgs } from './useQueryArgs'\n\n// TYPES\n\nexport interface UseQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, [TKey]>\n  config?: QueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useQuery<TResult, TError, TKey extends QueryKeyWithoutObject>(\n  queryKey: TKey,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObjectAndArray\n>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, [TKey]>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<TResult, TError, TKey extends TupleQueryKey>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, TKey>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Object syntax\nexport function useQuery<TResult, TError, TKey extends QueryKeyWithoutArray>(\n  config: UseQueryObjectConfig<TResult, TError, [TKey]>\n): QueryResult<TResult, TError>\n\nexport function useQuery<TResult, TError, TKey extends TupleQueryKey>(\n  config: UseQueryObjectConfig<TResult, TError, TKey>\n): QueryResult<TResult, TError>\n\n// Implementation\nexport function useQuery<TResult, TError>(\n  ...args: any[]\n): QueryResult<TResult, TError> {\n  const [queryKey, config] = useQueryArgs<TResult, TError>(args)\n  const result = useBaseQuery<TResult, TError>(queryKey, config)\n\n  handleSuspense(result)\n\n  return {\n    ...result,\n    data: result.query.state.data,\n  }\n}\n","import React from 'react'\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { handleSuspense } from './utils'\nimport { getStatusProps } from '../core/utils'\nimport {\n  PaginatedQueryConfig,\n  PaginatedQueryResult,\n  QueryKey,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObject,\n  QueryKeyWithoutObjectAndArray,\n  QueryStatus,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from '../core/types'\nimport { useQueryArgs } from './useQueryArgs'\n\n// A paginated query is more like a \"lag\" query, which means\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n\n// TYPES\n\nexport interface UsePaginatedQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, TKey>\n  config?: PaginatedQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObject\n>(\n  queryKey: TKey,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObjectAndArray\n>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, [TKey]>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult, TError, TKey extends TupleQueryKey>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, TKey>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Object syntax\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutArray\n>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError, [TKey]>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult, TError, TKey extends TupleQueryKey>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError, TKey>\n): PaginatedQueryResult<TResult, TError>\n\n// Implementation\nexport function usePaginatedQuery<TResult, TError>(\n  ...args: any[]\n): PaginatedQueryResult<TResult, TError> {\n  const [queryKey, config] = useQueryArgs<TResult, TError>(args)\n\n  // Keep track of the latest data result\n  const lastDataRef = React.useRef<TResult>()\n\n  // If latestData is there, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  // Make the query as normal\n  const result = useBaseQuery<TResult, TError>(queryKey, config)\n\n  // If the query is disabled, get rid of the latest data\n  if (!result.query.config.enabled) {\n    lastDataRef.current = undefined\n  }\n\n  // Get the real data and status from the query\n  const { data: latestData, status } = result.query.state\n\n  // If the real query succeeds, and there is data in it,\n  // update the latest data\n  React.useEffect(() => {\n    if (status === QueryStatus.Success && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  // Resolved data should be either the real data we're waiting on\n  // or the latest placeholder data\n  let resolvedData = latestData\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  // If we have any data at all from either, we\n  // need to make sure the status is success, even though\n  // the real query may still be loading\n  if (typeof resolvedData !== 'undefined') {\n    const overrides = getStatusProps(QueryStatus.Success)\n    Object.assign(result.query.state, overrides)\n    Object.assign(result, overrides)\n  }\n\n  handleSuspense(result)\n\n  return {\n    ...result,\n    resolvedData,\n    latestData,\n  }\n}\n","import React from 'react'\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { handleSuspense } from './utils'\nimport {\n  InfiniteQueryConfig,\n  InfiniteQueryResult,\n  QueryKey,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObject,\n  QueryKeyWithoutObjectAndArray,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from '../core/types'\nimport { useQueryArgs } from './useQueryArgs'\n\n// TYPES\n\nexport interface UseInfiniteQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, TKey>\n  config?: InfiniteQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObject\n>(\n  queryKey: TKey,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObjectAndArray\n>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, [TKey]>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult, TError, TKey extends TupleQueryKey>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, TKey>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Object syntax\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutArray\n>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError, [TKey]>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult, TError, TKey extends TupleQueryKey>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError, TKey>\n): InfiniteQueryResult<TResult, TError>\n\n// Implementation\nexport function useInfiniteQuery<TResult, TError>(\n  ...args: any[]\n): InfiniteQueryResult<TResult, TError> {\n  const [queryKey, config] = useQueryArgs<TResult[], TError>(args)\n\n  config.infinite = true\n\n  const result = useBaseQuery<TResult[], TError>(queryKey, config)\n  const query = result.query\n  const state = result.query.state\n\n  handleSuspense(result)\n\n  const fetchMore = React.useMemo(() => query.fetchMore.bind(query), [query])\n\n  return {\n    ...result,\n    data: state.data,\n    canFetchMore: state.canFetchMore,\n    fetchMore,\n    isFetching: state.isFetching,\n    isFetchingMore: state.isFetchingMore,\n  }\n}\n"],"names":["QueryStatus","_uid","uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","setConsole","c","functionalUpdate","updater","input","stableStringifyReplacer","_key","value","Error","isObject","Object","keys","sort","reduce","result","key","stableStringify","JSON","stringify","a","Array","isArray","deepIncludes","b","some","isDocumentVisible","visibilityState","document","_document","undefined","includes","getQueryArgs","args","queryKey","queryFn","config","options","equal","deep","depth","length","i","valueOf","prototype","hasOwnProperty","call","getStatusProps","status","isLoading","Loading","isSuccess","Success","isError","isIdle","Idle","DEFAULT_CONFIG","shared","suspense","queries","queryKeySerializerFn","arrayQueryKey","queryHash","parse","enabled","retry","retryDelay","attemptIndex","Math","min","staleTime","cacheTime","refetchOnWindowFocus","refetchInterval","queryFnParamsFilter","d","refetchOnMount","isDataEqual","useErrorBoundary","mutations","throwOnError","defaultConfigRef","current","ActionType","QueryInstance","query","onStateUpdate","id","clearInterval","this","refetchIntervalId","updateConfig","oldConfig","clearIntervals","minInterval","instances","map","Infinity","setInterval","_this","_","refetchIntervalInBackground","fetch","run","then","body","recover","e","wasSuspended","_this3","state","isStale","direct","Promise","resolve","unsubscribe","filter","_this4","cancel","scheduleGarbageCollection","_empty","f","arguments","apply","reject","pact","s","o","_settle","bind","v","observer","_Pact","onFulfilled","onRejected","callback","thenable","thrown","finalizer","Query","init","initialData","hasInitialData","initialStatus","queryCache","notifyGlobalListeners","initialStale","isFetching","failureCount","markedForGarbageCollection","data","updatedAt","Date","now","infinite","infiniteConfig","infiniteData","canFetchMore","fetchMoreVariable","getFetchMore","pageVariables","dispatch","action","newState","type","Failed","MarkStale","MarkGC","Fetch","cancelled","throwInErrorBoundary","SetState","queryReducer","forEach","scheduleStaleTimeout","clearStaleTimeout","staleTimeout","setTimeout","_this2","invalidate","clearCacheTimeout","cacheTimeout","removeQueries","refetch","_this5","heal","cancelPromises","promise","instance","clearTimeout","clearRetryTimeout","retryTimeout","setState","setData","clear","subscribe","push","tryFetchData","fn","promiseOrValue","_this7","_ref","shouldContinueRetryOnFocus","delay","_this9","fetchMore","originalQueryFn","rebuiltPageVariables","test","awaitBody","_isSettledPact","shouldContinue","_resumeAfterBody","_resumeAfterTest","shift","nextCursor","pageArgs","slice","previous","old","isFetchingMore","newArgs","newData","_async","getCallbackInstances","callbackInstances","fallbackInstance","unshift","onSuccess","onSettled","onError","QueryCache","globalListeners","configRef","defaultConfig","values","acc","listener","splice","indexOf","notify","getQueries","predicate","predicateFn","exact","getQuery","getQueryData","_this$getQuery","cancelQueries","invalidateQueries","refetchActive","refetchInactive","all","err","resetErrorBoundaries","buildQuery","userQueryKey","queryConfig","frozen","prefetchQuery","configWithoutRetry","_this6","force","setQueryData","makeQueryCache","queryCaches","removePreviousHandler","onWindowFocus","navigator","onLine","Boolean","catch","setFocusHandler","handleFocus","_window","addEventListener","removeEventListener","queryCacheContext","React","createContext","defaultQueryCache","useQueryCache","useContext","ReactQueryCacheProvider","children","resolvedQueryCache","useMemo","useEffect","Provider","configContext","useConfigContext","ReactQueryConfigProvider","configContextValueOrDefault","configContextValue","newConfig","contextShared","contextQueries","contextMutations","useGetLatest","obj","ref","useRef","useCallback","useMountedCallback","mounted","useRerenderer","rerender","useState","handleSuspense","useIsFetching","getIsFetching","newCache","_await","getDefaultState","mutationReducer","Reset","Resolve","Reject","useMutation","mutationFn","useReducer","getMutationFn","contextConfig","getConfig","latestMutationRef","mutate","variables","mutateConfig","mutationId","snapshotValue","isLatest","onMutate","reset","useBaseQuery","instanceRef","enabledBool","useQueryArgs","useQuery","usePaginatedQuery","lastDataRef","latestData","resolvedData","overrides","assign","useInfiniteQuery"],"mappings":"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"}