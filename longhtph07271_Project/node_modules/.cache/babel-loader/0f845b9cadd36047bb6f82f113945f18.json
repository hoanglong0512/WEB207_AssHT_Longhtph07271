{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} // The tuple variants are only to infer types in the public API\n\n\nvar QueryStatus;\n\n(function (QueryStatus) {\n  QueryStatus[\"Idle\"] = \"idle\";\n  QueryStatus[\"Loading\"] = \"loading\";\n  QueryStatus[\"Error\"] = \"error\";\n  QueryStatus[\"Success\"] = \"success\";\n})(QueryStatus || (QueryStatus = {})); // UTILS\n\n\nvar _uid = 0;\n\nvar uid = function uid() {\n  return _uid++;\n};\n\nvar cancelledError = {};\nvar isServer = typeof window === 'undefined';\n\nfunction noop() {\n  return void 0;\n}\n\nfunction identity(d) {\n  return d;\n}\n\nvar Console = console || {\n  error: noop,\n  warn: noop,\n  log: noop\n};\n\nfunction setConsole(c) {\n  Console = c;\n}\n\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\n\nfunction stableStringifyReplacer(_key, value) {\n  if (typeof value === 'function') {\n    throw new Error('Cannot stringify non JSON value');\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value).sort().reduce(function (result, key) {\n      result[key] = value[key];\n      return result;\n    }, {});\n  }\n\n  return value;\n}\n\nfunction stableStringify(value) {\n  return JSON.stringify(value, stableStringifyReplacer);\n}\n\nfunction isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a);\n}\n\nfunction deepIncludes(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(function (key) {\n      return !deepIncludes(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\nfunction isDocumentVisible() {\n  var _document;\n\n  var visibilityState = (_document = document) == null ? void 0 : _document.visibilityState;\n  return [undefined, 'visible', 'prerender'].includes(visibilityState);\n}\n\nfunction isOnline() {\n  return navigator.onLine === undefined || navigator.onLine;\n}\n\nfunction getQueryArgs(args) {\n  var queryKey;\n  var queryFn;\n  var config;\n  var options;\n\n  if (isObject(args[0])) {\n    queryKey = args[0].queryKey;\n    queryFn = args[0].queryFn;\n    config = args[0].config;\n    options = args[1];\n  } else if (isObject(args[1])) {\n    queryKey = args[0];\n    config = args[1];\n    options = args[2];\n  } else {\n    queryKey = args[0];\n    queryFn = args[1];\n    config = args[2];\n    options = args[3];\n  }\n\n  config = config || {};\n\n  if (queryFn) {\n    config = _extends({}, config, {\n      queryFn: queryFn\n    });\n  }\n\n  return [queryKey, config, options];\n}\n\nfunction deepEqual(a, b) {\n  return equal(a, b, true);\n}\n\nfunction shallowEqual(a, b) {\n  return equal(a, b, false);\n} // This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\n\n\nfunction equal(a, b, deep, depth) {\n  if (depth === void 0) {\n    depth = 0;\n  }\n\n  if (a === b) return true;\n\n  if ((deep || !depth) && a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i;\n\n    if (Array.isArray(a)) {\n      length = a.length; // eslint-disable-next-line eqeqeq\n\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i], deep, depth + 1)) return false;\n      }\n\n      return true;\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    var keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (!equal(a[key], b[key], deep, depth + 1)) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n\n\n  return a !== a && b !== b;\n}\n\nfunction getStatusProps(status) {\n  return {\n    status: status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle\n  };\n} // CONFIG\n\n\nvar defaultQueryKeySerializerFn = function defaultQueryKeySerializerFn(queryKey) {\n  try {\n    var arrayQueryKey = Array.isArray(queryKey) ? queryKey : [queryKey];\n    var queryHash = stableStringify(arrayQueryKey);\n    arrayQueryKey = JSON.parse(queryHash);\n    return [queryHash, arrayQueryKey];\n  } catch (_unused) {\n    throw new Error('A valid query key is required!');\n  }\n};\n\nvar DEFAULT_CONFIG = {\n  shared: {\n    suspense: false\n  },\n  queries: {\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    enabled: true,\n    retry: 3,\n    retryDelay: function retryDelay(attemptIndex) {\n      return Math.min(1000 * Math.pow(2, attemptIndex), 30000);\n    },\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    useErrorBoundary: false\n  },\n  mutations: {\n    throwOnError: false,\n    useErrorBoundary: false\n  }\n};\nvar defaultConfigRef = {\n  current: DEFAULT_CONFIG\n}; // CLASS\n\nfunction _empty() {}\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _continueIgnored(value) {\n  if (value && value.then) {\n    return value.then(_empty);\n  }\n}\n\nvar QueryInstance = /*#__PURE__*/function () {\n  function QueryInstance(query, onStateUpdate) {\n    this.id = uid();\n    this.onStateUpdate = onStateUpdate;\n    this.query = query;\n    this.config = {};\n  }\n\n  var _proto = QueryInstance.prototype;\n\n  _proto.clearInterval = function (_clearInterval) {\n    function clearInterval() {\n      return _clearInterval.apply(this, arguments);\n    }\n\n    clearInterval.toString = function () {\n      return _clearInterval.toString();\n    };\n\n    return clearInterval;\n  }(function () {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  });\n\n  _proto.updateConfig = function updateConfig(config) {\n    var _this = this;\n\n    var oldConfig = this.config; // Update the config\n\n    this.config = config;\n\n    if (!isServer) {\n      if ((oldConfig == null ? void 0 : oldConfig.refetchInterval) === config.refetchInterval) {\n        return;\n      }\n\n      this.query.clearIntervals();\n      var minInterval = Math.min.apply(Math, this.query.instances.map(function (d) {\n        return d.config.refetchInterval || Infinity;\n      }));\n\n      if (!this.refetchIntervalId && minInterval > 0 && minInterval < Infinity) {\n        this.refetchIntervalId = setInterval(function () {\n          if (_this.query.instances.some(function (_) {\n            return _this.config.enabled;\n          }) && (isDocumentVisible() || _this.query.instances.some(function (_) {\n            return _this.config.refetchIntervalInBackground;\n          }))) {\n            _this.query.fetch();\n          }\n        }, minInterval);\n      }\n    }\n  };\n\n  _proto.run = function run() {\n    try {\n      var _this3 = this;\n\n      return _continueIgnored(_catch(function () {\n        // Perform the refetch for this query if necessary\n        return _invoke(function () {\n          if (_this3.query.config.enabled && // Don't auto refetch if disabled\n          !_this3.query.wasSuspended && // Don't double refetch for suspense\n          _this3.query.state.isStale && ( // Only refetch if stale\n          _this3.query.config.refetchOnMount || _this3.query.instances.length === 1)) {\n            return _awaitIgnored(_this3.query.fetch());\n          }\n        }, function () {\n          _this3.query.wasSuspended = false;\n        });\n      }, function (error) {\n        Console.error(error);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.unsubscribe = function unsubscribe() {\n    var _this4 = this;\n\n    this.query.instances = this.query.instances.filter(function (d) {\n      return d.id !== _this4.id;\n    });\n\n    if (!this.query.instances.length) {\n      this.clearInterval();\n      this.query.cancel();\n\n      if (!isServer) {\n        // Schedule garbage collection\n        this.query.scheduleGarbageCollection();\n      }\n    }\n  };\n\n  return QueryInstance;\n}();\n\nfunction _empty$1() {}\n\nvar ActionType;\n\nfunction _awaitIgnored$1(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty$1) : Promise.resolve();\n  }\n}\n\nfunction _catch$1(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _continueIgnored$1(value) {\n  if (value && value.then) {\n    return value.then(_empty$1);\n  }\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _invoke$1(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction _invokeIgnored(body) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(_empty$1);\n  }\n}\n\nfunction _settle(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    var observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nvar _Pact = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    var result = new _Pact();\n    var state = this.s;\n\n    if (state) {\n      var callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle(result, 1, callback(this.v));\n        } catch (e) {\n          _settle(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        var value = _this.v;\n\n        if (_this.s & 1) {\n          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle(result, 1, onRejected(value));\n        } else {\n          _settle(result, 2, value);\n        }\n      } catch (e) {\n        _settle(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}();\n\nfunction _isSettledPact(thenable) {\n  return thenable instanceof _Pact && thenable.s & 1;\n}\n\nfunction _do(body, test) {\n  var awaitBody;\n\n  do {\n    var result = body();\n\n    if (result && result.then) {\n      if (_isSettledPact(result)) {\n        result = result.v;\n      } else {\n        awaitBody = true;\n        break;\n      }\n    }\n\n    var shouldContinue = test();\n\n    if (_isSettledPact(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n\n    if (!shouldContinue) {\n      return result;\n    }\n  } while (!shouldContinue.then);\n\n  var pact = new _Pact();\n\n  var reject = _settle.bind(null, pact, 2);\n\n  (awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n  return pact;\n\n  function _resumeAfterBody(value) {\n    result = value;\n\n    for (;;) {\n      shouldContinue = test();\n\n      if (_isSettledPact(shouldContinue)) {\n        shouldContinue = shouldContinue.v;\n      }\n\n      if (!shouldContinue) {\n        break;\n      }\n\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n\n      result = body();\n\n      if (result && result.then) {\n        if (_isSettledPact(result)) {\n          result = result.v;\n        } else {\n          result.then(_resumeAfterBody).then(void 0, reject);\n          return;\n        }\n      }\n    }\n\n    _settle(pact, 1, result);\n  }\n\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      do {\n        result = body();\n\n        if (result && result.then) {\n          if (_isSettledPact(result)) {\n            result = result.v;\n          } else {\n            result.then(_resumeAfterBody).then(void 0, reject);\n            return;\n          }\n        }\n\n        shouldContinue = test();\n\n        if (_isSettledPact(shouldContinue)) {\n          shouldContinue = shouldContinue.v;\n        }\n\n        if (!shouldContinue) {\n          _settle(pact, 1, result);\n\n          return;\n        }\n      } while (!shouldContinue.then);\n\n      shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n}\n\nfunction _continue(value, then) {\n  return value && value.then ? value.then(then) : then(value);\n}\n\nfunction _rethrow(thrown, value) {\n  if (thrown) throw value;\n  return value;\n}\n\nfunction _finallyRethrows(body, finalizer) {\n  try {\n    var result = body();\n  } catch (e) {\n    return finalizer(true, e);\n  }\n\n  if (result && result.then) {\n    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n  }\n\n  return finalizer(false, result);\n}\n\n(function (ActionType) {\n  ActionType[\"Failed\"] = \"Failed\";\n  ActionType[\"MarkStale\"] = \"MarkStale\";\n  ActionType[\"MarkGC\"] = \"MarkGC\";\n  ActionType[\"Fetch\"] = \"Fetch\";\n  ActionType[\"Success\"] = \"Success\";\n  ActionType[\"Error\"] = \"Error\";\n  ActionType[\"SetState\"] = \"SetState\";\n})(ActionType || (ActionType = {})); // CLASS\n\n\nvar Query = /*#__PURE__*/function () {\n  function Query(init) {\n    this.config = init.config;\n    this.queryCache = init.queryCache;\n    this.queryKey = init.queryKey;\n    this.queryHash = init.queryHash;\n    this.notifyGlobalListeners = init.notifyGlobalListeners;\n    this.instances = [];\n    this.state = getDefaultState(init.config);\n\n    if (init.config.infinite) {\n      var infiniteConfig = init.config;\n      var infiniteData = this.state.data;\n\n      if (typeof infiniteData !== 'undefined' && typeof this.state.canFetchMore === 'undefined') {\n        this.fetchMoreVariable = infiniteConfig.getFetchMore(infiniteData[infiniteData.length - 1], infiniteData);\n        this.state.canFetchMore = this.fetchMoreVariable !== false;\n      } // Here we seed the pageVariabes for the query\n\n\n      if (!this.pageVariables) {\n        this.pageVariables = [[].concat(this.queryKey)];\n      }\n    }\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.dispatch = function dispatch(action) {\n    var _this = this;\n\n    var newState = queryReducer(this.state, action); // Only update state if something has changed\n\n    if (!shallowEqual(this.state, newState)) {\n      this.state = newState;\n      this.instances.forEach(function (d) {\n        return d.onStateUpdate == null ? void 0 : d.onStateUpdate(_this.state);\n      });\n      this.notifyGlobalListeners(this);\n    }\n  };\n\n  _proto.scheduleStaleTimeout = function scheduleStaleTimeout() {\n    var _this2 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearStaleTimeout();\n\n    if (this.state.isStale) {\n      return;\n    }\n\n    if (this.config.staleTime === Infinity) {\n      return;\n    }\n\n    this.staleTimeout = setTimeout(function () {\n      _this2.invalidate();\n    }, this.config.staleTime);\n  };\n\n  _proto.invalidate = function invalidate() {\n    this.clearStaleTimeout();\n\n    if (!this.queryCache.queries[this.queryHash]) {\n      return;\n    }\n\n    if (this.state.isStale) {\n      return;\n    }\n\n    this.dispatch({\n      type: ActionType.MarkStale\n    });\n  };\n\n  _proto.scheduleGarbageCollection = function scheduleGarbageCollection() {\n    var _this3 = this;\n\n    this.clearCacheTimeout();\n\n    if (!this.queryCache.queries[this.queryHash]) {\n      return;\n    }\n\n    if (this.config.cacheTime === Infinity) {\n      return;\n    }\n\n    this.dispatch({\n      type: ActionType.MarkGC\n    });\n    this.cacheTimeout = setTimeout(function () {\n      _this3.queryCache.removeQueries(function (d) {\n        return d.state.markedForGarbageCollection && d.queryHash === _this3.queryHash;\n      });\n    }, typeof this.state.data === 'undefined' && this.state.status !== QueryStatus.Error ? 0 : this.config.cacheTime);\n  };\n\n  _proto.refetch = function refetch() {\n    try {\n      var _this5 = this;\n\n      return _continueIgnored$1(_catch$1(function () {\n        return _awaitIgnored$1(_this5.fetch());\n      }, function (error) {\n        Console.error(error);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.heal = function heal() {\n    // Stop the query from being garbage collected\n    this.clearCacheTimeout(); // Mark the query as not cancelled\n\n    this.cancelled = null;\n  };\n\n  _proto.cancel = function cancel() {\n    this.cancelled = cancelledError;\n\n    if (this.cancelPromises) {\n      this.cancelPromises();\n    }\n\n    delete this.promise;\n  };\n\n  _proto.clearIntervals = function clearIntervals() {\n    this.instances.forEach(function (instance) {\n      instance.clearInterval();\n    });\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    if (this.staleTimeout) {\n      clearTimeout(this.staleTimeout);\n      this.staleTimeout = undefined;\n    }\n  };\n\n  _proto.clearCacheTimeout = function clearCacheTimeout() {\n    if (this.cacheTimeout) {\n      clearTimeout(this.cacheTimeout);\n      this.cacheTimeout = undefined;\n    }\n  };\n\n  _proto.clearRetryTimeout = function clearRetryTimeout() {\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = undefined;\n    }\n  };\n\n  _proto.setState = function setState(updater) {\n    this.dispatch({\n      type: ActionType.SetState,\n      updater: updater\n    });\n  };\n\n  _proto.setData = function setData(updater) {\n    var isStale = this.config.staleTime === 0; // Set data and mark it as cached\n\n    this.dispatch({\n      type: ActionType.Success,\n      updater: updater,\n      isStale: isStale\n    });\n\n    if (!isStale) {\n      // Schedule a fresh invalidation!\n      this.scheduleStaleTimeout();\n    }\n  };\n\n  _proto.clear = function clear() {\n    this.clearStaleTimeout();\n    this.clearCacheTimeout();\n    this.clearRetryTimeout();\n    this.clearIntervals();\n    this.cancel();\n    delete this.queryCache.queries[this.queryHash];\n    this.notifyGlobalListeners(this);\n  };\n\n  _proto.subscribe = function subscribe(onStateUpdate) {\n    var instance = new QueryInstance(this, onStateUpdate);\n    this.instances.push(instance);\n    this.heal();\n    return instance;\n  } // Set up the core fetcher function\n  ;\n\n  _proto.tryFetchData = function tryFetchData(fn, args) {\n    try {\n      var _this7 = this;\n\n      return _catch$1(function () {\n        // Perform the query\n        var promiseOrValue = fn.apply(void 0, _this7.config.queryFnParamsFilter(args));\n\n        _this7.cancelPromises = function () {\n          var _ref;\n\n          return (_ref = promiseOrValue) == null ? void 0 : _ref.cancel == null ? void 0 : _ref.cancel();\n        };\n\n        return _await(promiseOrValue, function (data) {\n          delete _this7.shouldContinueRetryOnFocus;\n          delete _this7.cancelPromises;\n          if (_this7.cancelled) throw _this7.cancelled;\n          return data;\n        });\n      }, function (error) {\n        var _exit = false;\n        delete _this7.cancelPromises;\n        if (_this7.cancelled) throw _this7.cancelled; // Do we need to retry the request?\n\n        return _invoke$1(function () {\n          if (_this7.config.retry === true || _this7.state.failureCount < _this7.config.retry || typeof _this7.config.retry === 'function' && _this7.config.retry(_this7.state.failureCount, error)) {\n            // If we retry, increase the failureCount\n            _this7.dispatch({\n              type: ActionType.Failed\n            }); // Only retry if the document is visible\n\n\n            if (!isDocumentVisible()) {\n              // set this flag to continue retries on focus\n              _this7.shouldContinueRetryOnFocus = true; // Resolve a\n\n              _exit = true;\n              return new Promise(noop);\n            }\n\n            delete _this7.shouldContinueRetryOnFocus; // Determine the retryDelay\n\n            var delay = functionalUpdate(_this7.config.retryDelay, _this7.state.failureCount); // Return a new promise with the retry\n\n            _exit = true;\n            return _await(new Promise(function (resolve, reject) {\n              // Keep track of the retry timeout\n              _this7.retryTimeout = setTimeout(_async(function () {\n                return _this7.cancelled ? reject(_this7.cancelled) : _catch$1(function () {\n                  return _await(_this7.tryFetchData(fn, args), function (data) {\n                    if (_this7.cancelled) return reject(_this7.cancelled);\n                    resolve(data);\n                  });\n                }, function (error) {\n                  if (_this7.cancelled) return reject(_this7.cancelled);\n                  reject(error);\n                });\n              }), delay);\n            }));\n          }\n        }, function (_result) {\n          if (_exit) return _result;\n          throw error;\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetch = function fetch(options) {\n    try {\n      var _this9 = this;\n\n      var queryFn = _this9.config.queryFn;\n\n      if (!queryFn) {\n        return;\n      } // If we are already fetching, return current promise\n\n\n      if (_this9.promise) {\n        return _this9.promise;\n      }\n\n      if (_this9.config.infinite) {\n        var infiniteConfig = _this9.config;\n        var infiniteData = _this9.state.data;\n        var fetchMore = options == null ? void 0 : options.fetchMore;\n        var originalQueryFn = queryFn;\n        queryFn = _async(function () {\n          var _interrupt = false;\n          var data = [];\n          var pageVariables = _this9.pageVariables ? [].concat(_this9.pageVariables) : [];\n          var rebuiltPageVariables = [];\n          return _continue(_do(function () {\n            var args = pageVariables.shift();\n            return _invokeIgnored(function () {\n              if (!data.length) {\n                var _push3 = data.push; // the first page query doesn't need to be rebuilt\n\n                return _await(originalQueryFn.apply(void 0, args), function (_originalQueryFn) {\n                  _push3.call(data, _originalQueryFn);\n\n                  rebuiltPageVariables.push(args);\n                });\n              } else {\n                // get an up-to-date cursor based on the previous data set\n                var nextCursor = infiniteConfig.getFetchMore(data[data.length - 1], data); // break early if there's no next cursor\n                // otherwise we'll start from the beginning\n                // which will cause unwanted duplication\n\n                if (!nextCursor) {\n                  _interrupt = true;\n                  return;\n                }\n\n                var pageArgs = [].concat(args.slice(0, -1), [nextCursor]);\n                var _push4 = data.push;\n                return _await(originalQueryFn.apply(void 0, pageArgs), function (_originalQueryFn2) {\n                  _push4.call(data, _originalQueryFn2);\n\n                  rebuiltPageVariables.push(pageArgs);\n                });\n              }\n            });\n          }, function () {\n            return !_interrupt && !!pageVariables.length;\n          }), function () {\n            _this9.fetchMoreVariable = infiniteConfig.getFetchMore(data[data.length - 1], data);\n            _this9.state.canFetchMore = _this9.fetchMoreVariable !== false;\n            _this9.pageVariables = rebuiltPageVariables;\n            return data;\n          });\n        });\n\n        if (fetchMore) {\n          queryFn = _async(function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            return _finallyRethrows(function () {\n              var fetchMoreVariable = fetchMore.fetchMoreVariable,\n                  previous = fetchMore.previous;\n\n              _this9.setState(function (old) {\n                return _extends({}, old, {\n                  isFetchingMore: previous ? 'previous' : 'next'\n                });\n              });\n\n              var newArgs = [].concat(args, [fetchMoreVariable]);\n\n              if (_this9.pageVariables) {\n                _this9.pageVariables[previous ? 'unshift' : 'push'](newArgs);\n              } else {\n                _this9.pageVariables = [newArgs];\n              }\n\n              return _await(originalQueryFn.apply(void 0, newArgs), function (newData) {\n                var data;\n\n                if (!infiniteData) {\n                  data = [newData];\n                } else if (previous) {\n                  data = [newData].concat(infiniteData);\n                } else {\n                  data = [].concat(infiniteData, [newData]);\n                }\n\n                _this9.fetchMoreVariable = infiniteConfig.getFetchMore(newData, data);\n                _this9.state.canFetchMore = _this9.fetchMoreVariable !== false;\n                return data;\n              });\n            }, function (_wasThrown, _result3) {\n              _this9.setState(function (old) {\n                return _extends({}, old, {\n                  isFetchingMore: false\n                });\n              });\n\n              return _rethrow(_wasThrown, _result3);\n            });\n          });\n        }\n      }\n\n      _this9.promise = _async(function () {\n        // If there are any retries pending for this query, kill them\n        _this9.cancelled = null;\n\n        var getCallbackInstances = function getCallbackInstances() {\n          var callbackInstances = [].concat(_this9.instances);\n\n          if (_this9.wasSuspended && _this9.fallbackInstance) {\n            callbackInstances.unshift(_this9.fallbackInstance);\n          }\n\n          return callbackInstances;\n        };\n\n        return _catch$1(function () {\n          // Set up the query refreshing state\n          _this9.dispatch({\n            type: ActionType.Fetch\n          }); // Try to get the data\n\n\n          return _await(_this9.tryFetchData(queryFn, _this9.queryKey), function (data) {\n            _this9.setData(function (old) {\n              return _this9.config.isDataEqual(old, data) ? old : data;\n            });\n\n            getCallbackInstances().forEach(function (instance) {\n              instance.config.onSuccess == null ? void 0 : instance.config.onSuccess(_this9.state.data);\n            });\n            getCallbackInstances().forEach(function (instance) {\n              return instance.config.onSettled == null ? void 0 : instance.config.onSettled(_this9.state.data, null);\n            });\n            delete _this9.promise;\n            return data;\n          });\n        }, function (error) {\n          _this9.dispatch({\n            type: ActionType.Error,\n            cancelled: error === _this9.cancelled,\n            error: error\n          });\n\n          delete _this9.promise;\n\n          if (error !== _this9.cancelled) {\n            getCallbackInstances().forEach(function (instance) {\n              return instance.config.onError == null ? void 0 : instance.config.onError(error);\n            });\n            getCallbackInstances().forEach(function (instance) {\n              return instance.config.onSettled == null ? void 0 : instance.config.onSettled(undefined, error);\n            });\n            throw error;\n          }\n        });\n      })();\n      return _this9.promise;\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable != null ? fetchMoreVariable : this.fetchMoreVariable,\n        previous: (options == null ? void 0 : options.previous) || false\n      }\n    });\n  };\n\n  return Query;\n}();\n\nfunction getDefaultState(config) {\n  var _config$initialStale;\n\n  var initialData = typeof config.initialData === 'function' ? config.initialData() : config.initialData;\n  var hasInitialData = typeof initialData !== 'undefined';\n  var isStale = !config.enabled || (typeof config.initialStale === 'function' ? config.initialStale() : (_config$initialStale = config.initialStale) != null ? _config$initialStale : !hasInitialData);\n  var initialStatus = hasInitialData ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;\n  return _extends({}, getStatusProps(initialStatus), {\n    error: null,\n    isFetching: initialStatus === QueryStatus.Loading,\n    failureCount: 0,\n    isStale: isStale,\n    markedForGarbageCollection: false,\n    data: initialData,\n    updatedAt: hasInitialData ? Date.now() : 0\n  });\n}\n\nfunction queryReducer(state, action) {\n  switch (action.type) {\n    case ActionType.Failed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case ActionType.MarkStale:\n      return _extends({}, state, {\n        isStale: true\n      });\n\n    case ActionType.MarkGC:\n      {\n        return _extends({}, state, {\n          markedForGarbageCollection: true\n        });\n      }\n\n    case ActionType.Fetch:\n      var status = typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading;\n      return _extends({}, state, getStatusProps(status), {\n        isFetching: true,\n        failureCount: 0\n      });\n\n    case ActionType.Success:\n      return _extends({}, state, getStatusProps(QueryStatus.Success), {\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: action.isStale,\n        isFetching: false,\n        updatedAt: Date.now(),\n        failureCount: 0\n      });\n\n    case ActionType.Error:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isStale: true\n      }, !action.cancelled && _extends({}, getStatusProps(QueryStatus.Error), {\n        error: action.error,\n        throwInErrorBoundary: true\n      }));\n\n    case ActionType.SetState:\n      return functionalUpdate(action.updater, state);\n\n    default:\n      return state;\n  }\n} // CLASS\n\n\nfunction _empty$2() {}\n\nfunction _awaitIgnored$2(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty$2) : Promise.resolve();\n  }\n}\n\nfunction _catch$2(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _invoke$2(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nvar QueryCache = /*#__PURE__*/function () {\n  function QueryCache(config) {\n    this.config = config || {}; // A frozen cache does not add new queries to the cache\n\n    this.globalListeners = [];\n    this.configRef = this.config.defaultConfig ? {\n      current: {\n        shared: _extends({}, defaultConfigRef.current.shared, this.config.defaultConfig.shared),\n        queries: _extends({}, defaultConfigRef.current.queries, this.config.defaultConfig.queries),\n        mutations: _extends({}, defaultConfigRef.current.mutations, this.config.defaultConfig.mutations)\n      }\n    } : defaultConfigRef;\n    this.queries = {};\n    this.isFetching = 0;\n  }\n\n  var _proto = QueryCache.prototype;\n\n  _proto.notifyGlobalListeners = function notifyGlobalListeners(query) {\n    this.isFetching = Object.values(this.queries).reduce(function (acc, query) {\n      return query.state.isFetching ? acc + 1 : acc;\n    }, 0);\n    this.globalListeners.forEach(function (d) {\n      return d(queryCache, query);\n    });\n  };\n\n  _proto.subscribe = function subscribe(listener) {\n    var _this = this;\n\n    this.globalListeners.push(listener);\n    return function () {\n      _this.globalListeners.splice(_this.globalListeners.indexOf(listener), 1);\n    };\n  };\n\n  _proto.clear = function clear(options) {\n    Object.values(this.queries).forEach(function (query) {\n      return query.clear();\n    });\n    this.queries = {};\n\n    if (options == null ? void 0 : options.notify) {\n      this.notifyGlobalListeners();\n    }\n  };\n\n  _proto.getQueries = function getQueries(predicate, options) {\n    if (predicate === true) {\n      return Object.values(this.queries);\n    }\n\n    var predicateFn;\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate;\n    } else {\n      var _ref = this.configRef.current.queries.queryKeySerializerFn(predicate),\n          queryHash = _ref[0],\n          _queryKey = _ref[1];\n\n      predicateFn = function predicateFn(d) {\n        return (options == null ? void 0 : options.exact) ? d.queryHash === queryHash : deepIncludes(d.queryKey, _queryKey);\n      };\n    }\n\n    return Object.values(this.queries).filter(predicateFn);\n  };\n\n  _proto.getQuery = function getQuery(predicate) {\n    return this.getQueries(predicate, {\n      exact: true\n    })[0];\n  };\n\n  _proto.getQueryData = function getQueryData(predicate) {\n    var _this$getQuery;\n\n    return (_this$getQuery = this.getQuery(predicate)) == null ? void 0 : _this$getQuery.state.data;\n  };\n\n  _proto.removeQueries = function removeQueries(predicate, options) {\n    this.getQueries(predicate, options).forEach(function (query) {\n      return query.clear();\n    });\n  };\n\n  _proto.cancelQueries = function cancelQueries(predicate, options) {\n    this.getQueries(predicate, options).forEach(function (query) {\n      return query.cancel();\n    });\n  };\n\n  _proto.invalidateQueries = function invalidateQueries(predicate, options) {\n    try {\n      var _this3 = this;\n\n      var _ref2 = options || {},\n          _ref2$refetchActive = _ref2.refetchActive,\n          refetchActive = _ref2$refetchActive === void 0 ? true : _ref2$refetchActive,\n          _ref2$refetchInactive = _ref2.refetchInactive,\n          refetchInactive = _ref2$refetchInactive === void 0 ? false : _ref2$refetchInactive,\n          throwOnError = _ref2.throwOnError;\n\n      return _catch$2(function () {\n        return _awaitIgnored$2(Promise.all(_this3.getQueries(predicate, options).map(function (query) {\n          if (query.instances.length) {\n            if (refetchActive && query.instances.some(function (instance) {\n              return instance.config.enabled;\n            })) {\n              return query.fetch();\n            }\n          } else {\n            if (refetchInactive) {\n              return query.fetch();\n            }\n          }\n\n          return query.invalidate();\n        })));\n      }, function (err) {\n        if (throwOnError) {\n          throw err;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.resetErrorBoundaries = function resetErrorBoundaries() {\n    this.getQueries(true).forEach(function (query) {\n      query.state.throwInErrorBoundary = false;\n    });\n  };\n\n  _proto.buildQuery = function buildQuery(userQueryKey, queryConfig) {\n    var _this4 = this;\n\n    if (queryConfig === void 0) {\n      queryConfig = {};\n    }\n\n    var config = _extends({}, this.configRef.current.shared, this.configRef.current.queries, queryConfig);\n\n    var _ref3 = config.queryKeySerializerFn(userQueryKey),\n        queryHash = _ref3[0],\n        queryKey = _ref3[1];\n\n    var query;\n\n    if (this.queries[queryHash]) {\n      query = this.queries[queryHash];\n      query.config = config;\n    }\n\n    if (!query) {\n      query = new Query({\n        queryCache: queryCache,\n        queryKey: queryKey,\n        queryHash: queryHash,\n        config: config,\n        notifyGlobalListeners: function notifyGlobalListeners(query) {\n          _this4.notifyGlobalListeners(query);\n        }\n      }); // If the query started with data, schedule\n      // a stale timeout\n\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout(); // Simulate a query healing process\n\n        query.heal(); // Schedule for garbage collection in case\n        // nothing subscribes to this query\n\n        query.scheduleGarbageCollection();\n      }\n\n      if (!this.config.frozen) {\n        this.queries[queryHash] = query;\n\n        if (isServer) {\n          this.notifyGlobalListeners();\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(function () {\n            _this4.notifyGlobalListeners();\n          });\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled\n      }\n    };\n    return query;\n  } // Parameter syntax with optional prefetch options\n  ; // Implementation\n\n\n  _proto.prefetchQuery = function prefetchQuery() {\n    try {\n      var _this6 = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (isObject(args[1]) && (args[1].hasOwnProperty('throwOnError') || args[1].hasOwnProperty('force'))) {\n        args[3] = args[1];\n        args[1] = undefined;\n        args[2] = undefined;\n      }\n\n      var _getQueryArgs = getQueryArgs(args),\n          _queryKey2 = _getQueryArgs[0],\n          _config = _getQueryArgs[1],\n          _options = _getQueryArgs[2]; // https://github.com/tannerlinsley/react-query/issues/652\n\n\n      var configWithoutRetry = _extends({\n        retry: false\n      }, _config);\n\n      return _catch$2(function () {\n        var query = _this6.buildQuery(_queryKey2, configWithoutRetry);\n\n        return _invoke$2(function () {\n          if ((_options == null ? void 0 : _options.force) || query.state.isStale) {\n            return _awaitIgnored$2(query.fetch());\n          }\n        }, function () {\n          return query.state.data;\n        });\n      }, function (err) {\n        if (_options == null ? void 0 : _options.throwOnError) {\n          throw err;\n        }\n\n        Console.error(err);\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.setQueryData = function setQueryData(queryKey, updater, config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    var query = this.getQuery(queryKey);\n\n    if (!query) {\n      query = this.buildQuery(queryKey, config);\n    }\n\n    query.setData(updater);\n  };\n\n  return QueryCache;\n}();\n\nvar queryCache = makeQueryCache({\n  frozen: isServer\n});\nvar queryCaches = [queryCache];\n\nfunction makeQueryCache(config) {\n  return new QueryCache(config);\n}\n\nvar visibilityChangeEvent = 'visibilitychange';\nvar focusEvent = 'focus';\n\nvar onWindowFocus = function onWindowFocus() {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(function (queryCache) {\n      return queryCache.invalidateQueries(function (query) {\n        if (!query.instances.length) {\n          return false;\n        }\n\n        if (!query.instances.some(function (instance) {\n          return instance.config.enabled;\n        })) {\n          return false;\n        }\n\n        if (!query.state.isStale) {\n          return false;\n        }\n\n        if (query.shouldContinueRetryOnFocus) {\n          // delete promise, so refetching will create new one\n          delete query.promise;\n        }\n\n        return Boolean(query.config.refetchOnWindowFocus);\n      }).catch(Console.error);\n    });\n  }\n};\n\nvar removePreviousHandler;\n\nfunction setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler();\n  } // Sub the new watcher\n\n\n  removePreviousHandler = callback(onWindowFocus);\n}\n\nsetFocusHandler(function (handleFocus) {\n  var _window; // Listen to visibillitychange and focus\n\n\n  if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false);\n    window.addEventListener(focusEvent, handleFocus, false);\n    return function () {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus);\n      window.removeEventListener(focusEvent, handleFocus);\n    };\n  }\n\n  return;\n});\nvar queryCacheContext = React.createContext(queryCache);\n\nvar useQueryCache = function useQueryCache() {\n  return React.useContext(queryCacheContext);\n};\n\nvar ReactQueryCacheProvider = function ReactQueryCacheProvider(_ref) {\n  var queryCache = _ref.queryCache,\n      children = _ref.children;\n  var resolvedQueryCache = React.useMemo(function () {\n    return queryCache || makeQueryCache();\n  }, [queryCache]);\n  React.useEffect(function () {\n    queryCaches.push(resolvedQueryCache);\n    return function () {\n      // remove the cache from the active list\n      var i = queryCaches.indexOf(resolvedQueryCache);\n\n      if (i > -1) {\n        queryCaches.splice(i, 1);\n      } // if the resolvedQueryCache was created by us, we need to tear it down\n\n\n      if (queryCache == null) {\n        resolvedQueryCache.clear({\n          notify: false\n        });\n      }\n    };\n  }, [resolvedQueryCache, queryCache]);\n  return /*#__PURE__*/React.createElement(queryCacheContext.Provider, {\n    value: resolvedQueryCache\n  }, children);\n};\n\nvar configContext = React.createContext(undefined);\n\nfunction useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current;\n}\n\nvar ReactQueryConfigProvider = function ReactQueryConfigProvider(_ref) {\n  var config = _ref.config,\n      children = _ref.children;\n  var configContextValueOrDefault = useConfigContext();\n  var configContextValue = React.useContext(configContext);\n  var newConfig = React.useMemo(function () {\n    var _config$shared = config.shared,\n        shared = _config$shared === void 0 ? {} : _config$shared,\n        _config$queries = config.queries,\n        queries = _config$queries === void 0 ? {} : _config$queries,\n        _config$mutations = config.mutations,\n        mutations = _config$mutations === void 0 ? {} : _config$mutations;\n    var _configContextValueOr = configContextValueOrDefault.shared,\n        contextShared = _configContextValueOr === void 0 ? {} : _configContextValueOr,\n        _configContextValueOr2 = configContextValueOrDefault.queries,\n        contextQueries = _configContextValueOr2 === void 0 ? {} : _configContextValueOr2,\n        _configContextValueOr3 = configContextValueOrDefault.mutations,\n        contextMutations = _configContextValueOr3 === void 0 ? {} : _configContextValueOr3;\n    return {\n      shared: _extends({}, contextShared, shared),\n      queries: _extends({}, contextQueries, queries),\n      mutations: _extends({}, contextMutations, mutations)\n    };\n  }, [config, configContextValueOrDefault]);\n  React.useEffect(function () {\n    // restore previous config on unmount\n    return function () {\n      defaultConfigRef.current = _extends({}, configContextValueOrDefault || DEFAULT_CONFIG);\n    };\n  }, [configContextValueOrDefault]); // If this is the outermost provider, overwrite the shared default config\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig;\n  }\n\n  return /*#__PURE__*/React.createElement(configContext.Provider, {\n    value: newConfig\n  }, children);\n};\n\nfunction useGetLatest(obj) {\n  var ref = React.useRef(obj);\n  ref.current = obj;\n  return React.useCallback(function () {\n    return ref.current;\n  }, []);\n}\n\nfunction useMountedCallback(callback) {\n  var mounted = React.useRef(false);\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {\n    mounted.current = true;\n    return function () {\n      mounted.current = false;\n    };\n  }, []);\n  return React.useCallback(function () {\n    return mounted.current ? callback.apply(void 0, arguments) : void 0;\n  }, [callback]);\n}\n\nfunction useRerenderer() {\n  var rerender = useMountedCallback(React.useState()[1]);\n  return React.useCallback(function () {\n    return rerender({});\n  }, [rerender]);\n}\n\nfunction handleSuspense(result) {\n  var error = result.error,\n      query = result.query;\n  var config = query.config,\n      state = query.state;\n\n  if (config.suspense || config.useErrorBoundary) {\n    if (state.status === QueryStatus.Error && state.throwInErrorBoundary) {\n      throw error;\n    }\n\n    if (config.suspense && state.status !== QueryStatus.Success && config.enabled) {\n      query.wasSuspended = true;\n      throw query.fetch();\n    }\n  }\n}\n\nfunction useIsFetching() {\n  var queryCache = useQueryCache();\n  var rerender = useRerenderer();\n  var isFetching = queryCache.isFetching;\n  var getIsFetching = useGetLatest(isFetching);\n  React.useEffect(function () {\n    return queryCache.subscribe(function (newCache) {\n      if (getIsFetching() !== newCache.isFetching) {\n        rerender();\n      }\n    });\n  }, [getIsFetching, queryCache, rerender]);\n  return isFetching;\n}\n\nfunction _await$1(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nvar ActionType$1;\n\nfunction _catch$3(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async$1(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\n(function (ActionType) {\n  ActionType[\"Reset\"] = \"Reset\";\n  ActionType[\"Loading\"] = \"Loading\";\n  ActionType[\"Resolve\"] = \"Resolve\";\n  ActionType[\"Reject\"] = \"Reject\";\n})(ActionType$1 || (ActionType$1 = {})); // HOOK\n\n\nvar getDefaultState$1 = function getDefaultState() {\n  return _extends({}, getStatusProps(QueryStatus.Idle), {\n    data: undefined,\n    error: null\n  });\n};\n\nfunction mutationReducer(state, action) {\n  switch (action.type) {\n    case ActionType$1.Reset:\n      return getDefaultState$1();\n\n    case ActionType$1.Loading:\n      return _extends({}, getStatusProps(QueryStatus.Loading), {\n        data: undefined,\n        error: null\n      });\n\n    case ActionType$1.Resolve:\n      return _extends({}, getStatusProps(QueryStatus.Success), {\n        data: action.data,\n        error: null\n      });\n\n    case ActionType$1.Reject:\n      return _extends({}, getStatusProps(QueryStatus.Error), {\n        data: undefined,\n        error: action.error\n      });\n\n    default:\n      return state;\n  }\n}\n\nfunction useMutation(mutationFn, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState$1),\n      state = _React$useReducer[0],\n      unsafeDispatch = _React$useReducer[1];\n\n  var dispatch = useMountedCallback(unsafeDispatch);\n  var getMutationFn = useGetLatest(mutationFn);\n  var contextConfig = useConfigContext();\n  var getConfig = useGetLatest(_extends({}, contextConfig.shared, contextConfig.mutations, config));\n  var latestMutationRef = React.useRef();\n  var mutate = React.useCallback(_async$1(function (variables, mutateConfig) {\n    if (mutateConfig === void 0) {\n      mutateConfig = {};\n    }\n\n    var config = getConfig();\n    var mutationId = uid();\n    latestMutationRef.current = mutationId;\n\n    var isLatest = function isLatest() {\n      return latestMutationRef.current === mutationId;\n    };\n\n    var snapshotValue;\n    return _catch$3(function () {\n      dispatch({\n        type: ActionType$1.Loading\n      });\n      return _await$1(config.onMutate == null ? void 0 : config.onMutate(variables), function (_config$onMutate) {\n        snapshotValue = _config$onMutate;\n        return _await$1(getMutationFn()(variables), function (data) {\n          if (isLatest()) {\n            dispatch({\n              type: ActionType$1.Resolve,\n              data: data\n            });\n          }\n\n          return _await$1(config.onSuccess == null ? void 0 : config.onSuccess(data, variables), function () {\n            return _await$1(mutateConfig.onSuccess == null ? void 0 : mutateConfig.onSuccess(data, variables), function () {\n              return _await$1(config.onSettled == null ? void 0 : config.onSettled(data, null, variables), function () {\n                return _await$1(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(data, null, variables), function () {\n                  return data;\n                });\n              });\n            });\n          });\n        });\n      });\n    }, function (error) {\n      Console.error(error);\n      return _await$1(config.onError == null ? void 0 : config.onError(error, variables, snapshotValue), function () {\n        return _await$1(mutateConfig.onError == null ? void 0 : mutateConfig.onError(error, variables, snapshotValue), function () {\n          return _await$1(config.onSettled == null ? void 0 : config.onSettled(undefined, error, variables, snapshotValue), function () {\n            return _await$1(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(undefined, error, variables, snapshotValue), function () {\n              var _mutateConfig$throwOn;\n\n              if (isLatest()) {\n                dispatch({\n                  type: ActionType$1.Reject,\n                  error: error\n                });\n              }\n\n              if ((_mutateConfig$throwOn = mutateConfig.throwOnError) != null ? _mutateConfig$throwOn : config.throwOnError) {\n                throw error;\n              }\n            });\n          });\n        });\n      });\n    });\n  }), [dispatch, getConfig, getMutationFn]);\n  var reset = React.useCallback(function () {\n    dispatch({\n      type: ActionType$1.Reset\n    });\n  }, [dispatch]);\n  React.useEffect(function () {\n    var _getConfig = getConfig(),\n        suspense = _getConfig.suspense,\n        useErrorBoundary = _getConfig.useErrorBoundary;\n\n    if ((useErrorBoundary != null ? useErrorBoundary : suspense) && state.error) {\n      throw state.error;\n    }\n  }, [getConfig, state.error]);\n  return [mutate, _extends({}, state, {\n    reset: reset\n  })];\n}\n\nfunction useBaseQuery(queryKey, config) {\n  if (config === void 0) {\n    config = {};\n  } // Make a rerender function\n\n\n  var rerender = useRerenderer(); // Get the query cache\n\n  var queryCache = useQueryCache(); // Build the query for use\n\n  var query = queryCache.buildQuery(queryKey, config);\n  var state = query.state; // Create a query instance ref\n\n  var instanceRef = React.useRef(); // Subscribe to the query when the subscribe function changes\n\n  React.useEffect(function () {\n    var instance = query.subscribe(function () {\n      rerender();\n    });\n    instanceRef.current = instance; // Unsubscribe when things change\n\n    return function () {\n      return instance.unsubscribe();\n    };\n  }, [query, rerender]); // Always update the config\n\n  React.useEffect(function () {\n    var _instanceRef$current;\n\n    (_instanceRef$current = instanceRef.current) == null ? void 0 : _instanceRef$current.updateConfig(config);\n  });\n  var enabledBool = Boolean(config.enabled); // Run the instance when the query or enabled change\n\n  React.useEffect(function () {\n    var _instanceRef$current2;\n\n    (_instanceRef$current2 = instanceRef.current) == null ? void 0 : _instanceRef$current2.run();\n  }, [enabledBool, query]);\n  var clear = React.useMemo(function () {\n    return query.clear.bind(query);\n  }, [query]);\n  var refetch = React.useMemo(function () {\n    return query.refetch.bind(query);\n  }, [query]);\n  return {\n    clear: clear,\n    error: state.error,\n    failureCount: state.failureCount,\n    isError: state.isError,\n    isFetching: state.isFetching,\n    isIdle: state.isIdle,\n    isLoading: state.isLoading,\n    isStale: state.isStale,\n    isSuccess: state.isSuccess,\n    query: query,\n    refetch: refetch,\n    status: state.status,\n    updatedAt: state.updatedAt\n  };\n}\n\nfunction useQueryArgs(args) {\n  var configContext = useConfigContext();\n\n  var _getQueryArgs = getQueryArgs(args),\n      queryKey = _getQueryArgs[0],\n      config = _getQueryArgs[1],\n      options = _getQueryArgs[2]; // Build the final config\n\n\n  var configWithContext = _extends({}, configContext.shared, configContext.queries, config);\n\n  return [queryKey, configWithContext, options];\n} // Implementation\n\n\nfunction useQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _useQueryArgs = useQueryArgs(args),\n      queryKey = _useQueryArgs[0],\n      config = _useQueryArgs[1];\n\n  var result = useBaseQuery(queryKey, config);\n  handleSuspense(result);\n  return _extends({}, result, {\n    data: result.query.state.data\n  });\n} // as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n// TYPES\n// Implementation\n\n\nfunction usePaginatedQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _useQueryArgs = useQueryArgs(args),\n      queryKey = _useQueryArgs[0],\n      config = _useQueryArgs[1]; // Keep track of the latest data result\n\n\n  var lastDataRef = React.useRef(); // If latestData is there, don't use initialData\n\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData;\n  } // Make the query as normal\n\n\n  var result = useBaseQuery(queryKey, config); // If the query is disabled, get rid of the latest data\n\n  if (!result.query.config.enabled) {\n    lastDataRef.current = undefined;\n  } // Get the real data and status from the query\n\n\n  var _result$query$state = result.query.state,\n      latestData = _result$query$state.data,\n      status = _result$query$state.status; // If the real query succeeds, and there is data in it,\n  // update the latest data\n\n  React.useEffect(function () {\n    if (status === QueryStatus.Success && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData;\n    }\n  }, [latestData, status]); // Resolved data should be either the real data we're waiting on\n  // or the latest placeholder data\n\n  var resolvedData = latestData;\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current;\n  } // If we have any data at all from either, we\n  // need to make sure the status is success, even though\n  // the real query may still be loading\n\n\n  if (typeof resolvedData !== 'undefined') {\n    var overrides = getStatusProps(QueryStatus.Success);\n    Object.assign(result.query.state, overrides);\n    Object.assign(result, overrides);\n  }\n\n  handleSuspense(result);\n  return _extends({}, result, {\n    resolvedData: resolvedData,\n    latestData: latestData\n  });\n} // Implementation\n\n\nfunction useInfiniteQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _useQueryArgs = useQueryArgs(args),\n      queryKey = _useQueryArgs[0],\n      config = _useQueryArgs[1];\n\n  config.infinite = true;\n  var result = useBaseQuery(queryKey, config);\n  var query = result.query;\n  var state = result.query.state;\n  handleSuspense(result);\n  var fetchMore = React.useMemo(function () {\n    return query.fetchMore.bind(query);\n  }, [query]);\n  return _extends({}, result, {\n    data: state.data,\n    canFetchMore: state.canFetchMore,\n    fetchMore: fetchMore,\n    isFetching: state.isFetching,\n    isFetchingMore: state.isFetchingMore\n  });\n}\n\nexport { QueryStatus, ReactQueryCacheProvider, ReactQueryConfigProvider, deepIncludes, makeQueryCache, queryCache, queryCaches, setConsole, setFocusHandler, stableStringify, useInfiniteQuery, useIsFetching, useMutation, usePaginatedQuery, useQuery, useQueryCache };","map":{"version":3,"sources":["../src/core/types.ts","../src/core/utils.ts","../src/core/config.ts","../src/core/queryInstance.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/setFocusHandler.ts","../src/react/ReactQueryCacheProvider.tsx","../src/react/ReactQueryConfigProvider.tsx","../src/react/utils.ts","../src/react/useIsFetching.ts","../src/react/useMutation.ts","../src/react/useBaseQuery.ts","../src/react/useQueryArgs.ts","../src/react/useQuery.ts","../src/react/usePaginatedQuery.ts","../src/react/useInfiniteQuery.ts"],"names":["QueryStatus","_uid","uid","cancelledError","isServer","Console","console","error","warn","log","noop","updater","isObject","result","value","JSON","a","Array","deepIncludes","b","visibilityState","document","navigator","args","queryKey","queryFn","config","options","equal","depth","deep","length","i","Object","keys","key","status","isLoading","isSuccess","isError","isIdle","Idle","defaultQueryKeySerializerFn","arrayQueryKey","queryHash","stableStringify","DEFAULT_CONFIG","shared","suspense","queries","queryKeySerializerFn","enabled","retry","retryDelay","Math","staleTime","cacheTime","refetchOnWindowFocus","refetchInterval","queryFnParamsFilter","refetchOnMount","isDataEqual","useErrorBoundary","mutations","throwOnError","defaultConfigRef","current","QueryInstance","clearInterval","updateConfig","oldConfig","minInterval","d","setInterval","isDocumentVisible","unsubscribe","Promise","body","then","recover","state","callback","_this","onFulfilled","onRejected","pact","observer","ActionType","thenable","arguments","f","Query","init","getDefaultState","infiniteConfig","infiniteData","newState","queryReducer","shallowEqual","scheduleStaleTimeout","setTimeout","invalidate","type","MarkStale","scheduleGarbageCollection","MarkGC","heal","cancel","clearIntervals","instance","clearTimeout","setData","isStale","clear","subscribe","promiseOrValue","fn","awaitBody","shouldContinue","test","Failed","reject","delay","functionalUpdate","resolve","fetchMore","originalQueryFn","data","pageVariables","rebuiltPageVariables","nextCursor","pageArgs","fetchMoreVariable","previous","isFetchingMore","newArgs","getCallbackInstances","callbackInstances","Fetch","cancelled","finalizer","initialData","hasInitialData","initialStatus","getStatusProps","isFetching","failureCount","markedForGarbageCollection","updatedAt","Date","action","throwInErrorBoundary","QueryCache","query","acc","getQueries","predicate","predicateFn","getQuery","exact","getQueryData","removeQueries","cancelQueries","refetchActive","refetchInactive","resetErrorBoundaries","buildQuery","queryConfig","queryCache","notifyGlobalListeners","onSuccess","onError","onSettled","getQueryArgs","configWithoutRetry","setQueryData","makeQueryCache","frozen","queryCaches","visibilityChangeEvent","focusEvent","onWindowFocus","isOnline","Boolean","removePreviousHandler","setFocusHandler","window","queryCacheContext","React","useQueryCache","ReactQueryCacheProvider","children","resolvedQueryCache","notify","configContext","ReactQueryConfigProvider","configContextValueOrDefault","useConfigContext","configContextValue","newConfig","contextShared","contextQueries","contextMutations","ref","mounted","rerender","useMountedCallback","useRerenderer","getIsFetching","useGetLatest","newCache","unsafeDispatch","dispatch","getMutationFn","contextConfig","getConfig","latestMutationRef","mutate","mutateConfig","mutationId","isLatest","Loading","snapshotValue","reset","Reset","instanceRef","enabledBool","refetch","configWithContext","useQueryArgs","useBaseQuery","handleSuspense","lastDataRef","latestData","resolvedData","overrides","canFetchMore"],"mappings":"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","sourcesContent":["import { Query, FetchMoreOptions } from './query'\n\nexport type QueryKeyObject =\n  | object\n  | { [key: string]: QueryKey }\n  | { [key: number]: QueryKey }\n\nexport type QueryKeyPrimitive = string | boolean | number | null | undefined\n\nexport type QueryKeyWithoutObjectAndArray = QueryKeyPrimitive\n\nexport type QueryKeyWithoutObject =\n  | QueryKeyWithoutObjectAndArray\n  | readonly QueryKey[]\n\nexport type QueryKeyWithoutArray =\n  | QueryKeyWithoutObjectAndArray\n  | QueryKeyObject\n\nexport type QueryKey = QueryKeyWithoutObject | QueryKeyObject\n\nexport type ArrayQueryKey = QueryKey[]\n\nexport type QueryFunction<TResult> = (\n  ...args: any[]\n) => TResult | Promise<TResult>\n\n// The tuple variants are only to infer types in the public API\nexport type TupleQueryKey = readonly [QueryKey, ...QueryKey[]]\n\nexport type TupleQueryFunction<TResult, TKey extends TupleQueryKey> = (\n  ...args: TKey\n) => TResult | Promise<TResult>\n\nexport type InitialDataFunction<TResult> = () => TResult | undefined\n\nexport type InitialStaleFunction = () => boolean\n\nexport type QueryKeySerializerFunction = (\n  queryKey: QueryKey\n) => [string, QueryKey[]]\n\nexport interface BaseQueryConfig<TResult, TError = unknown> {\n  /**\n   * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   */\n  enabled?: boolean | unknown\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: boolean | number | ((failureCount: number, error: TError) => boolean)\n  retryDelay?: number | ((retryAttempt: number) => number)\n  staleTime?: number\n  cacheTime?: number\n  refetchInterval?: false | number\n  refetchIntervalInBackground?: boolean\n  refetchOnWindowFocus?: boolean\n  refetchOnMount?: boolean\n  onSuccess?: (data: TResult) => void\n  onError?: (err: TError) => void\n  onSettled?: (data: TResult | undefined, error: TError | null) => void\n  isDataEqual?: (oldData: unknown, newData: unknown) => boolean\n  useErrorBoundary?: boolean\n  queryFn?: QueryFunction<TResult>\n  queryKeySerializerFn?: QueryKeySerializerFunction\n  queryFnParamsFilter?: (args: ArrayQueryKey) => ArrayQueryKey\n  suspense?: boolean\n  initialData?: TResult | InitialDataFunction<TResult>\n  initialStale?: boolean | InitialStaleFunction\n  infinite?: true\n}\n\nexport interface QueryConfig<TResult, TError = unknown>\n  extends BaseQueryConfig<TResult, TError> {}\n\nexport interface PaginatedQueryConfig<TResult, TError = unknown>\n  extends BaseQueryConfig<TResult, TError> {}\n\nexport interface InfiniteQueryConfig<TResult, TError = unknown>\n  extends BaseQueryConfig<TResult[], TError> {\n  getFetchMore: (lastPage: TResult, allPages: TResult[]) => unknown\n}\n\nexport type IsFetchingMoreValue = 'previous' | 'next' | false\n\nexport enum QueryStatus {\n  Idle = 'idle',\n  Loading = 'loading',\n  Error = 'error',\n  Success = 'success',\n}\n\nexport interface QueryResultBase<TResult, TError = unknown> {\n  status: QueryStatus\n  error: TError | null\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  isIdle: boolean\n  isFetching: boolean\n  isStale: boolean\n  failureCount: number\n  query: Query<TResult, TError>\n  updatedAt: number\n  refetch: () => Promise<void>\n  clear: () => void\n}\n\nexport interface QueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {\n  data: TResult | undefined\n}\n\nexport interface PaginatedQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {\n  resolvedData: TResult | undefined\n  latestData: TResult | undefined\n}\n\nexport interface InfiniteQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult[], TError> {\n  data: TResult[] | undefined\n  isFetchingMore?: IsFetchingMoreValue\n  canFetchMore: boolean | undefined\n  fetchMore: (\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ) => Promise<TResult[] | undefined> | undefined\n}\n\nexport interface MutateConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> {\n  onSuccess?: (data: TResult, variables: TVariables) => Promise<void> | void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    snapshotValue: TSnapshot\n  ) => Promise<void> | void\n  onSettled?: (\n    data: undefined | TResult,\n    error: TError | null,\n    variables: TVariables,\n    snapshotValue?: TSnapshot\n  ) => Promise<void> | void\n  throwOnError?: boolean\n}\n\nexport interface MutationConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutateConfig<TResult, TError, TVariables, TSnapshot> {\n  onMutate?: (variables: TVariables) => Promise<TSnapshot> | TSnapshot\n  useErrorBoundary?: boolean\n  suspense?: boolean\n}\n\nexport type MutationFunction<TResult, TVariables = unknown> = (\n  variables: TVariables\n) => Promise<TResult>\n\nexport type MutateFunction<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> = (\n  variables?: TVariables,\n  config?: MutateConfig<TResult, TError, TVariables, TSnapshot>\n) => Promise<TResult | undefined>\n\nexport type MutationResultPair<TResult, TError, TVariables, TSnapshot> = [\n  MutateFunction<TResult, TError, TVariables, TSnapshot>,\n  MutationResult<TResult, TError>\n]\n\nexport interface MutationResult<TResult, TError = unknown> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  reset: () => void\n}\n\nexport interface ReactQueryConfig<TResult = unknown, TError = unknown> {\n  queries?: ReactQueryQueriesConfig<TResult, TError>\n  shared?: ReactQuerySharedConfig\n  mutations?: ReactQueryMutationsConfig<TResult, TError>\n}\n\nexport interface ReactQuerySharedConfig {\n  suspense?: boolean\n}\n\nexport interface ReactQueryQueriesConfig<TResult, TError>\n  extends BaseQueryConfig<TResult, TError> {}\n\nexport interface ReactQueryMutationsConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutationConfig<TResult, TError, TVariables, TSnapshot> {}\n","import { QueryConfig, QueryStatus, QueryKey, QueryFunction } from './types'\n\n// TYPES\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\ntype ConsoleFunction = (...args: any[]) => void\n\nexport interface ConsoleObject {\n  log: ConsoleFunction\n  warn: ConsoleFunction\n  error: ConsoleFunction\n}\n\n// UTILS\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport const globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport function noop(): void {\n  return void 0\n}\nexport function identity<T>(d: T): T {\n  return d\n}\nexport let Console: ConsoleObject = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function setConsole(c: ConsoleObject) {\n  Console = c\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nfunction stableStringifyReplacer(_key: string, value: any): unknown {\n  if (typeof value === 'function') {\n    throw new Error('Cannot stringify non JSON value')\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value)\n      .sort()\n      .reduce((result, key) => {\n        result[key] = value[key]\n        return result\n      }, {} as any)\n  }\n\n  return value\n}\n\nexport function stableStringify(value: any): string {\n  return JSON.stringify(value, stableStringifyReplacer)\n}\n\nexport function isObject(a: unknown): boolean {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible(): boolean {\n  const visibilityState = document?.visibilityState as any\n\n  return [undefined, 'visible', 'prerender'].includes(visibilityState)\n}\n\nexport function isOnline(): boolean {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs<TResult, TError, TOptions = undefined>(\n  args: any[]\n): [QueryKey, QueryConfig<TResult, TError>, TOptions] {\n  let queryKey: QueryKey\n  let queryFn: QueryFunction<TResult> | undefined\n  let config: QueryConfig<TResult, TError> | undefined\n  let options: TOptions\n\n  if (isObject(args[0])) {\n    queryKey = args[0].queryKey\n    queryFn = args[0].queryFn\n    config = args[0].config\n    options = args[1]\n  } else if (isObject(args[1])) {\n    queryKey = args[0]\n    config = args[1]\n    options = args[2]\n  } else {\n    queryKey = args[0]\n    queryFn = args[1]\n    config = args[2]\n    options = args[3]\n  }\n\n  config = config || {}\n\n  if (queryFn) {\n    config = { ...config, queryFn }\n  }\n\n  return [queryKey, config, options]\n}\n\nexport function deepEqual(a: any, b: any): boolean {\n  return equal(a, b, true)\n}\n\nexport function shallowEqual(a: any, b: any): boolean {\n  return equal(a, b, false)\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nfunction equal(a: any, b: any, deep: boolean, depth = 0): boolean {\n  if (a === b) return true\n\n  if (\n    (deep || !depth) &&\n    a &&\n    b &&\n    typeof a == 'object' &&\n    typeof b == 'object'\n  ) {\n    let length, i\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; )\n        if (!equal(a[i], b[i], deep, depth + 1)) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    const keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      const key = keys[i]\n\n      if (!equal(a[key], b[key], deep, depth + 1)) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle,\n  }\n}\n","import { stableStringify, identity, deepEqual } from './utils'\nimport {\n  ArrayQueryKey,\n  QueryKey,\n  QueryKeySerializerFunction,\n  ReactQueryConfig,\n} from './types'\n\n// TYPES\n\nexport interface ReactQueryConfigRef {\n  current: ReactQueryConfig\n}\n\n// CONFIG\n\nexport const defaultQueryKeySerializerFn: QueryKeySerializerFunction = (\n  queryKey: QueryKey\n): [string, ArrayQueryKey] => {\n  try {\n    let arrayQueryKey: ArrayQueryKey = Array.isArray(queryKey)\n      ? queryKey\n      : [queryKey]\n    const queryHash = stableStringify(arrayQueryKey)\n    arrayQueryKey = JSON.parse(queryHash)\n    return [queryHash, arrayQueryKey]\n  } catch {\n    throw new Error('A valid query key is required!')\n  }\n}\n\nexport const DEFAULT_CONFIG: ReactQueryConfig = {\n  shared: {\n    suspense: false,\n  },\n  queries: {\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    useErrorBoundary: false,\n  },\n  mutations: {\n    throwOnError: false,\n    useErrorBoundary: false,\n  },\n}\n\nexport const defaultConfigRef: ReactQueryConfigRef = {\n  current: DEFAULT_CONFIG,\n}\n","import { uid, isServer, isDocumentVisible, Console } from './utils'\nimport { Query, QueryState } from './query'\nimport { BaseQueryConfig } from './types'\n\n// TYPES\n\nexport type OnStateUpdateFunction<TResult, TError> = (\n  state: QueryState<TResult, TError>\n) => void\n\n// CLASS\n\nexport class QueryInstance<TResult, TError> {\n  id: number\n  config: BaseQueryConfig<TResult, TError>\n  onStateUpdate?: OnStateUpdateFunction<TResult, TError>\n\n  private query: Query<TResult, TError>\n  private refetchIntervalId?: number\n\n  constructor(\n    query: Query<TResult, TError>,\n    onStateUpdate?: OnStateUpdateFunction<TResult, TError>\n  ) {\n    this.id = uid()\n    this.onStateUpdate = onStateUpdate\n    this.query = query\n    this.config = {}\n  }\n\n  clearInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  updateConfig(config: BaseQueryConfig<TResult, TError>): void {\n    const oldConfig = this.config\n\n    // Update the config\n    this.config = config\n\n    if (!isServer) {\n      if (oldConfig?.refetchInterval === config.refetchInterval) {\n        return\n      }\n\n      this.query.clearIntervals()\n\n      const minInterval = Math.min(\n        ...this.query.instances.map(d => d.config.refetchInterval || Infinity)\n      )\n\n      if (\n        !this.refetchIntervalId &&\n        minInterval > 0 &&\n        minInterval < Infinity\n      ) {\n        this.refetchIntervalId = setInterval(() => {\n          if (\n            this.query.instances.some(_ => this.config.enabled) &&\n            (isDocumentVisible() ||\n              this.query.instances.some(\n                _ => this.config.refetchIntervalInBackground\n              ))\n          ) {\n            this.query.fetch()\n          }\n        }, minInterval)\n      }\n    }\n  }\n\n  async run(): Promise<void> {\n    try {\n      // Perform the refetch for this query if necessary\n      if (\n        this.query.config.enabled && // Don't auto refetch if disabled\n        !this.query.wasSuspended && // Don't double refetch for suspense\n        this.query.state.isStale && // Only refetch if stale\n        (this.query.config.refetchOnMount || this.query.instances.length === 1)\n      ) {\n        await this.query.fetch()\n      }\n\n      this.query.wasSuspended = false\n    } catch (error) {\n      Console.error(error)\n    }\n  }\n\n  unsubscribe(): void {\n    this.query.instances = this.query.instances.filter(d => d.id !== this.id)\n\n    if (!this.query.instances.length) {\n      this.clearInterval()\n      this.query.cancel()\n\n      if (!isServer) {\n        // Schedule garbage collection\n        this.query.scheduleGarbageCollection()\n      }\n    }\n  }\n}\n","import {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  noop,\n  Console,\n  getStatusProps,\n  shallowEqual,\n  Updater,\n} from './utils'\nimport { QueryInstance, OnStateUpdateFunction } from './queryInstance'\nimport {\n  ArrayQueryKey,\n  InfiniteQueryConfig,\n  InitialDataFunction,\n  IsFetchingMoreValue,\n  QueryConfig,\n  QueryFunction,\n  QueryStatus,\n} from './types'\nimport { QueryCache } from './queryCache'\n\n// TYPES\n\ninterface QueryInitConfig<TResult, TError> {\n  queryCache: QueryCache\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  notifyGlobalListeners: (query: Query<TResult, TError>) => void\n}\n\nexport interface QueryState<TResult, TError> {\n  canFetchMore?: boolean\n  data?: TResult\n  error: TError | null\n  failureCount: number\n  isError: boolean\n  isFetching: boolean\n  isFetchingMore?: IsFetchingMoreValue\n  isIdle: boolean\n  isLoading: boolean\n  isStale: boolean\n  isSuccess: boolean\n  markedForGarbageCollection: boolean\n  status: QueryStatus\n  throwInErrorBoundary?: boolean\n  updatedAt: number\n}\n\ninterface FetchOptions {\n  fetchMore?: FetchMoreOptions\n}\n\nexport interface FetchMoreOptions {\n  fetchMoreVariable?: unknown\n  previous: boolean\n}\n\nenum ActionType {\n  Failed = 'Failed',\n  MarkStale = 'MarkStale',\n  MarkGC = 'MarkGC',\n  Fetch = 'Fetch',\n  Success = 'Success',\n  Error = 'Error',\n  SetState = 'SetState',\n}\n\ninterface FailedAction {\n  type: ActionType.Failed\n}\n\ninterface MarkStaleAction {\n  type: ActionType.MarkStale\n}\n\ninterface MarkGCAction {\n  type: ActionType.MarkGC\n}\n\ninterface FetchAction {\n  type: ActionType.Fetch\n}\n\ninterface SuccessAction<TResult> {\n  type: ActionType.Success\n  updater: Updater<TResult | undefined, TResult>\n  isStale: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: ActionType.Error\n  cancelled: boolean\n  error: TError\n}\n\ninterface SetStateAction<TResult, TError> {\n  type: ActionType.SetState\n  updater: Updater<QueryState<TResult, TError>, QueryState<TResult, TError>>\n}\n\ntype Action<TResult, TError> =\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | MarkGCAction\n  | MarkStaleAction\n  | SetStateAction<TResult, TError>\n  | SuccessAction<TResult>\n\n// CLASS\n\nexport class Query<TResult, TError> {\n  queryCache: QueryCache\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  instances: QueryInstance<TResult, TError>[]\n  state: QueryState<TResult, TError>\n  fallbackInstance?: QueryInstance<TResult, TError>\n  wasSuspended?: boolean\n  shouldContinueRetryOnFocus?: boolean\n  promise?: Promise<TResult | undefined>\n\n  private fetchMoreVariable?: unknown\n  private pageVariables?: ArrayQueryKey[]\n  private cacheTimeout?: number\n  private retryTimeout?: number\n  private staleTimeout?: number\n  private cancelPromises?: () => void\n  private cancelled?: typeof cancelledError | null\n  private notifyGlobalListeners: (query: Query<TResult, TError>) => void\n\n  constructor(init: QueryInitConfig<TResult, TError>) {\n    this.config = init.config\n    this.queryCache = init.queryCache\n    this.queryKey = init.queryKey\n    this.queryHash = init.queryHash\n    this.notifyGlobalListeners = init.notifyGlobalListeners\n    this.instances = []\n    this.state = getDefaultState(init.config)\n\n    if (init.config.infinite) {\n      const infiniteConfig = init.config as InfiniteQueryConfig<TResult, TError>\n      const infiniteData = (this.state.data as unknown) as TResult[] | undefined\n\n      if (\n        typeof infiniteData !== 'undefined' &&\n        typeof this.state.canFetchMore === 'undefined'\n      ) {\n        this.fetchMoreVariable = infiniteConfig.getFetchMore(\n          infiniteData[infiniteData.length - 1],\n          infiniteData\n        )\n        this.state.canFetchMore = this.fetchMoreVariable !== false\n      }\n\n      // Here we seed the pageVariabes for the query\n      if (!this.pageVariables) {\n        this.pageVariables = [[...this.queryKey]]\n      }\n    }\n  }\n\n  private dispatch(action: Action<TResult, TError>): void {\n    const newState = queryReducer(this.state, action)\n\n    // Only update state if something has changed\n    if (!shallowEqual(this.state, newState)) {\n      this.state = newState\n      this.instances.forEach(d => d.onStateUpdate?.(this.state))\n      this.notifyGlobalListeners(this)\n    }\n  }\n\n  scheduleStaleTimeout(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearStaleTimeout()\n\n    if (this.state.isStale) {\n      return\n    }\n\n    if (this.config.staleTime === Infinity) {\n      return\n    }\n\n    this.staleTimeout = setTimeout(() => {\n      this.invalidate()\n    }, this.config.staleTime)\n  }\n\n  invalidate(): void {\n    this.clearStaleTimeout()\n\n    if (!this.queryCache.queries[this.queryHash]) {\n      return\n    }\n\n    if (this.state.isStale) {\n      return\n    }\n\n    this.dispatch({ type: ActionType.MarkStale })\n  }\n\n  scheduleGarbageCollection(): void {\n    this.clearCacheTimeout()\n\n    if (!this.queryCache.queries[this.queryHash]) {\n      return\n    }\n\n    if (this.config.cacheTime === Infinity) {\n      return\n    }\n\n    this.dispatch({ type: ActionType.MarkGC })\n\n    this.cacheTimeout = setTimeout(\n      () => {\n        this.queryCache.removeQueries(\n          d =>\n            d.state.markedForGarbageCollection && d.queryHash === this.queryHash\n        )\n      },\n      typeof this.state.data === 'undefined' &&\n        this.state.status !== QueryStatus.Error\n        ? 0\n        : this.config.cacheTime\n    )\n  }\n\n  async refetch(): Promise<void> {\n    try {\n      await this.fetch()\n    } catch (error) {\n      Console.error(error)\n    }\n  }\n\n  heal(): void {\n    // Stop the query from being garbage collected\n    this.clearCacheTimeout()\n\n    // Mark the query as not cancelled\n    this.cancelled = null\n  }\n\n  cancel(): void {\n    this.cancelled = cancelledError\n\n    if (this.cancelPromises) {\n      this.cancelPromises()\n    }\n\n    delete this.promise\n  }\n\n  clearIntervals(): void {\n    this.instances.forEach(instance => {\n      instance.clearInterval()\n    })\n  }\n\n  private clearStaleTimeout() {\n    if (this.staleTimeout) {\n      clearTimeout(this.staleTimeout)\n      this.staleTimeout = undefined\n    }\n  }\n\n  private clearCacheTimeout() {\n    if (this.cacheTimeout) {\n      clearTimeout(this.cacheTimeout)\n      this.cacheTimeout = undefined\n    }\n  }\n\n  private clearRetryTimeout() {\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout)\n      this.retryTimeout = undefined\n    }\n  }\n\n  private setState(\n    updater: Updater<QueryState<TResult, TError>, QueryState<TResult, TError>>\n  ): void {\n    this.dispatch({ type: ActionType.SetState, updater })\n  }\n\n  setData(updater: Updater<TResult | undefined, TResult>): void {\n    const isStale = this.config.staleTime === 0\n    // Set data and mark it as cached\n    this.dispatch({\n      type: ActionType.Success,\n      updater,\n      isStale,\n    })\n\n    if (!isStale) {\n      // Schedule a fresh invalidation!\n      this.scheduleStaleTimeout()\n    }\n  }\n\n  clear(): void {\n    this.clearStaleTimeout()\n    this.clearCacheTimeout()\n    this.clearRetryTimeout()\n    this.clearIntervals()\n    this.cancel()\n    delete this.queryCache.queries[this.queryHash]\n    this.notifyGlobalListeners(this)\n  }\n\n  subscribe(\n    onStateUpdate?: OnStateUpdateFunction<TResult, TError>\n  ): QueryInstance<TResult, TError> {\n    const instance = new QueryInstance(this, onStateUpdate)\n    this.instances.push(instance)\n    this.heal()\n    return instance\n  }\n\n  // Set up the core fetcher function\n  private async tryFetchData(\n    fn: QueryFunction<TResult>,\n    args: ArrayQueryKey\n  ): Promise<TResult> {\n    try {\n      // Perform the query\n      const promiseOrValue = fn(...this.config.queryFnParamsFilter!(args))\n\n      this.cancelPromises = () => (promiseOrValue as any)?.cancel?.()\n\n      const data = await promiseOrValue\n      delete this.shouldContinueRetryOnFocus\n\n      delete this.cancelPromises\n      if (this.cancelled) throw this.cancelled\n\n      return data\n    } catch (error) {\n      delete this.cancelPromises\n      if (this.cancelled) throw this.cancelled\n\n      // Do we need to retry the request?\n      if (\n        this.config.retry === true ||\n        this.state.failureCount < this.config.retry! ||\n        (typeof this.config.retry === 'function' &&\n          this.config.retry(this.state.failureCount, error))\n      ) {\n        // If we retry, increase the failureCount\n        this.dispatch({ type: ActionType.Failed })\n\n        // Only retry if the document is visible\n        if (!isDocumentVisible()) {\n          // set this flag to continue retries on focus\n          this.shouldContinueRetryOnFocus = true\n          // Resolve a\n          return new Promise(noop)\n        }\n\n        delete this.shouldContinueRetryOnFocus\n\n        // Determine the retryDelay\n        const delay = functionalUpdate(\n          this.config.retryDelay,\n          this.state.failureCount\n        )\n\n        // Return a new promise with the retry\n        return await new Promise((resolve, reject) => {\n          // Keep track of the retry timeout\n          this.retryTimeout = setTimeout(async () => {\n            if (this.cancelled) return reject(this.cancelled)\n\n            try {\n              const data = await this.tryFetchData(fn, args)\n              if (this.cancelled) return reject(this.cancelled)\n              resolve(data)\n            } catch (error) {\n              if (this.cancelled) return reject(this.cancelled)\n              reject(error)\n            }\n          }, delay)\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async fetch(options?: FetchOptions): Promise<TResult | undefined> {\n    let queryFn = this.config.queryFn\n\n    if (!queryFn) {\n      return\n    }\n\n    // If we are already fetching, return current promise\n    if (this.promise) {\n      return this.promise\n    }\n\n    if (this.config.infinite) {\n      const infiniteConfig = this.config as InfiniteQueryConfig<TResult, TError>\n      const infiniteData = (this.state.data as unknown) as TResult[] | undefined\n      const fetchMore = options?.fetchMore\n\n      const originalQueryFn = queryFn\n\n      queryFn = async () => {\n        const data: TResult[] = []\n        const pageVariables = this.pageVariables ? [...this.pageVariables] : []\n        const rebuiltPageVariables: ArrayQueryKey[] = []\n\n        do {\n          const args = pageVariables.shift()!\n\n          if (!data.length) {\n            // the first page query doesn't need to be rebuilt\n            data.push(await originalQueryFn(...args))\n            rebuiltPageVariables.push(args)\n          } else {\n            // get an up-to-date cursor based on the previous data set\n\n            const nextCursor = infiniteConfig.getFetchMore(\n              data[data.length - 1],\n              data\n            )\n\n            // break early if there's no next cursor\n            // otherwise we'll start from the beginning\n            // which will cause unwanted duplication\n            if (!nextCursor) {\n              break\n            }\n\n            const pageArgs = [\n              // remove the last argument (the previously saved cursor)\n              ...args.slice(0, -1),\n              nextCursor,\n            ] as ArrayQueryKey\n\n            data.push(await originalQueryFn(...pageArgs))\n            rebuiltPageVariables.push(pageArgs)\n          }\n        } while (pageVariables.length)\n\n        this.fetchMoreVariable = infiniteConfig.getFetchMore(\n          data[data.length - 1],\n          data\n        )\n        this.state.canFetchMore = this.fetchMoreVariable !== false\n        this.pageVariables = rebuiltPageVariables\n\n        return (data as unknown) as TResult\n      }\n\n      if (fetchMore) {\n        queryFn = async (...args: ArrayQueryKey) => {\n          try {\n            const { fetchMoreVariable, previous } = fetchMore\n\n            this.setState(old => ({\n              ...old,\n              isFetchingMore: previous ? 'previous' : 'next',\n            }))\n\n            const newArgs = [...args, fetchMoreVariable] as ArrayQueryKey\n\n            if (this.pageVariables) {\n              this.pageVariables[previous ? 'unshift' : 'push'](newArgs)\n            } else {\n              this.pageVariables = [newArgs]\n            }\n\n            const newData = await originalQueryFn(...newArgs)\n\n            let data\n\n            if (!infiniteData) {\n              data = [newData]\n            } else if (previous) {\n              data = [newData, ...infiniteData]\n            } else {\n              data = [...infiniteData, newData]\n            }\n\n            this.fetchMoreVariable = infiniteConfig.getFetchMore(newData, data)\n            this.state.canFetchMore = this.fetchMoreVariable !== false\n\n            return (data as unknown) as TResult\n          } finally {\n            this.setState(old => ({\n              ...old,\n              isFetchingMore: false,\n            }))\n          }\n        }\n      }\n    }\n\n    this.promise = (async () => {\n      // If there are any retries pending for this query, kill them\n      this.cancelled = null\n\n      const getCallbackInstances = () => {\n        const callbackInstances = [...this.instances]\n\n        if (this.wasSuspended && this.fallbackInstance) {\n          callbackInstances.unshift(this.fallbackInstance)\n        }\n        return callbackInstances\n      }\n\n      try {\n        // Set up the query refreshing state\n        this.dispatch({ type: ActionType.Fetch })\n\n        // Try to get the data\n        const data = await this.tryFetchData(queryFn!, this.queryKey)\n\n        this.setData(old => (this.config.isDataEqual!(old, data) ? old! : data))\n\n        getCallbackInstances().forEach(instance => {\n          instance.config.onSuccess?.(this.state.data!)\n        })\n\n        getCallbackInstances().forEach(instance =>\n          instance.config.onSettled?.(this.state.data, null)\n        )\n\n        delete this.promise\n\n        return data\n      } catch (error) {\n        this.dispatch({\n          type: ActionType.Error,\n          cancelled: error === this.cancelled,\n          error,\n        })\n\n        delete this.promise\n\n        if (error !== this.cancelled) {\n          getCallbackInstances().forEach(instance =>\n            instance.config.onError?.(error)\n          )\n\n          getCallbackInstances().forEach(instance =>\n            instance.config.onSettled?.(undefined, error)\n          )\n\n          throw error\n        }\n\n        return\n      }\n    })()\n\n    return this.promise\n  }\n\n  fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ): Promise<TResult | undefined> {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable ?? this.fetchMoreVariable,\n        previous: options?.previous || false,\n      },\n    })\n  }\n}\n\nfunction getDefaultState<TResult, TError>(\n  config: QueryConfig<TResult, TError>\n): QueryState<TResult, TError> {\n  const initialData =\n    typeof config.initialData === 'function'\n      ? (config.initialData as InitialDataFunction<TResult>)()\n      : config.initialData\n\n  const hasInitialData = typeof initialData !== 'undefined'\n\n  const isStale =\n    !config.enabled ||\n    (typeof config.initialStale === 'function'\n      ? config.initialStale()\n      : config.initialStale ?? !hasInitialData)\n\n  const initialStatus = hasInitialData\n    ? QueryStatus.Success\n    : config.enabled\n    ? QueryStatus.Loading\n    : QueryStatus.Idle\n\n  return {\n    ...getStatusProps(initialStatus),\n    error: null,\n    isFetching: initialStatus === QueryStatus.Loading,\n    failureCount: 0,\n    isStale,\n    markedForGarbageCollection: false,\n    data: initialData,\n    updatedAt: hasInitialData ? Date.now() : 0,\n  }\n}\n\nexport function queryReducer<TResult, TError>(\n  state: QueryState<TResult, TError>,\n  action: Action<TResult, TError>\n): QueryState<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Failed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case ActionType.MarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case ActionType.MarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case ActionType.Fetch:\n      const status =\n        typeof state.data !== 'undefined'\n          ? QueryStatus.Success\n          : QueryStatus.Loading\n      return {\n        ...state,\n        ...getStatusProps(status),\n        isFetching: true,\n        failureCount: 0,\n      }\n    case ActionType.Success:\n      return {\n        ...state,\n        ...getStatusProps(QueryStatus.Success),\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: action.isStale,\n        isFetching: false,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case ActionType.Error:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          ...getStatusProps(QueryStatus.Error),\n          error: action.error,\n          throwInErrorBoundary: true,\n        }),\n      }\n    case ActionType.SetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      return state\n  }\n}\n","import {\n  isServer,\n  getQueryArgs,\n  deepIncludes,\n  Console,\n  isObject,\n  Updater,\n} from './utils'\nimport { defaultConfigRef, ReactQueryConfigRef } from './config'\nimport { Query } from './query'\nimport {\n  QueryConfig,\n  QueryKey,\n  QueryKeyWithoutObject,\n  ReactQueryConfig,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObjectAndArray,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from './types'\nimport { QueryInstance } from './queryInstance'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  frozen?: boolean\n  defaultConfig?: ReactQueryConfig\n}\n\ninterface ClearOptions {\n  notify?: boolean\n}\n\ninterface PrefetchQueryOptions {\n  force?: boolean\n  throwOnError?: boolean\n}\n\ninterface InvalidateQueriesOptions extends QueryPredicateOptions {\n  refetchActive?: boolean\n  refetchInactive?: boolean\n  throwOnError?: boolean\n}\n\ninterface QueryPredicateOptions {\n  exact?: boolean\n}\n\ntype QueryPredicate = QueryKey | QueryPredicateFn | true\n\ntype QueryPredicateFn = (query: Query<unknown, unknown>) => boolean\n\nexport interface PrefetchQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, TKey>\n  config?: QueryConfig<TResult, TError>\n  options?: PrefetchQueryOptions\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (\n  cache: QueryCache,\n  query?: Query<unknown, unknown>\n) => void\n\n// CLASS\n\nexport class QueryCache {\n  queries: QueryHashMap\n  isFetching: number\n\n  private config: QueryCacheConfig\n  private configRef: ReactQueryConfigRef\n  private globalListeners: QueryCacheListener[]\n\n  constructor(config?: QueryCacheConfig) {\n    this.config = config || {}\n\n    // A frozen cache does not add new queries to the cache\n    this.globalListeners = []\n\n    this.configRef = this.config.defaultConfig\n      ? {\n          current: {\n            shared: {\n              ...defaultConfigRef.current.shared,\n              ...this.config.defaultConfig.shared,\n            },\n            queries: {\n              ...defaultConfigRef.current.queries,\n              ...this.config.defaultConfig.queries,\n            },\n            mutations: {\n              ...defaultConfigRef.current.mutations,\n              ...this.config.defaultConfig.mutations,\n            },\n          },\n        }\n      : defaultConfigRef\n\n    this.queries = {}\n    this.isFetching = 0\n  }\n\n  private notifyGlobalListeners(query?: Query<any, any>) {\n    this.isFetching = Object.values(this.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    this.globalListeners.forEach(d => d(queryCache, query))\n  }\n\n  subscribe(listener: QueryCacheListener): () => void {\n    this.globalListeners.push(listener)\n    return () => {\n      this.globalListeners.splice(this.globalListeners.indexOf(listener), 1)\n    }\n  }\n\n  clear(options?: ClearOptions): void {\n    Object.values(this.queries).forEach(query => query.clear())\n    this.queries = {}\n    if (options?.notify) {\n      this.notifyGlobalListeners()\n    }\n  }\n\n  getQueries<TResult = unknown, TError = unknown>(\n    predicate: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): Query<TResult, TError>[] {\n    if (predicate === true) {\n      return Object.values(this.queries)\n    }\n\n    let predicateFn: QueryPredicateFn\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate as QueryPredicateFn\n    } else {\n      const [queryHash, queryKey] = this.configRef.current.queries!\n        .queryKeySerializerFn!(predicate)\n\n      predicateFn = d =>\n        options?.exact\n          ? d.queryHash === queryHash\n          : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(this.queries).filter(predicateFn)\n  }\n\n  getQuery<TResult, TError = unknown>(\n    predicate: QueryPredicate\n  ): Query<TResult, TError> | undefined {\n    return this.getQueries<TResult, TError>(predicate, { exact: true })[0]\n  }\n\n  getQueryData<TResult>(predicate: QueryPredicate): TResult | undefined {\n    return this.getQuery<TResult>(predicate)?.state.data\n  }\n\n  removeQueries(\n    predicate: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => query.clear())\n  }\n\n  cancelQueries(\n    predicate: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => query.cancel())\n  }\n\n  async invalidateQueries(\n    predicate: QueryPredicate,\n    options?: InvalidateQueriesOptions\n  ): Promise<void> {\n    const { refetchActive = true, refetchInactive = false, throwOnError } =\n      options || {}\n\n    try {\n      await Promise.all(\n        this.getQueries(predicate, options).map(query => {\n          if (query.instances.length) {\n            if (\n              refetchActive &&\n              query.instances.some(instance => instance.config.enabled)\n            ) {\n              return query.fetch()\n            }\n          } else {\n            if (refetchInactive) {\n              return query.fetch()\n            }\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  resetErrorBoundaries(): void {\n    this.getQueries(true).forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  buildQuery<TResult, TError = unknown>(\n    userQueryKey: QueryKey,\n    queryConfig: QueryConfig<TResult, TError> = {}\n  ): Query<TResult, TError> {\n    const config = {\n      ...this.configRef.current.shared!,\n      ...this.configRef.current.queries!,\n      ...queryConfig,\n    } as QueryConfig<TResult, TError>\n\n    const [queryHash, queryKey] = config.queryKeySerializerFn!(userQueryKey)\n\n    let query\n\n    if (this.queries[queryHash]) {\n      query = this.queries[queryHash] as Query<TResult, TError>\n      query.config = config\n    }\n\n    if (!query) {\n      query = new Query<TResult, TError>({\n        queryCache,\n        queryKey,\n        queryHash,\n        config,\n        notifyGlobalListeners: query => {\n          this.notifyGlobalListeners(query)\n        },\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (!this.config.frozen) {\n        this.queries[queryHash] = query\n\n        if (isServer) {\n          this.notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            this.notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled,\n      },\n    } as QueryInstance<TResult, TError>\n\n    return query\n  }\n\n  // Parameter syntax with optional prefetch options\n  async prefetchQuery<TResult, TError, TKey extends QueryKeyWithoutObject>(\n    queryKey: TKey,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with config and optional prefetch options\n  async prefetchQuery<TResult, TError, TKey extends QueryKeyWithoutObject>(\n    queryKey: TKey,\n    config: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function and optional prefetch options\n  async prefetchQuery<\n    TResult,\n    TError,\n    TKey extends QueryKeyWithoutObjectAndArray\n  >(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, [TKey]>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult, TError, TKey extends TupleQueryKey>(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, TKey>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function, config and optional prefetch options\n  async prefetchQuery<\n    TResult,\n    TError,\n    TKey extends QueryKeyWithoutObjectAndArray\n  >(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, [TKey]>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult, TError, TKey extends TupleQueryKey>(\n    queryKey: TKey,\n    queryFn: TupleQueryFunction<TResult, TKey>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Object syntax\n  async prefetchQuery<TResult, TError, TKey extends QueryKeyWithoutArray>(\n    config: PrefetchQueryObjectConfig<TResult, TError, [TKey]>\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult, TError, TKey extends TupleQueryKey>(\n    config: PrefetchQueryObjectConfig<TResult, TError, TKey>\n  ): Promise<TResult | undefined>\n\n  // Implementation\n  async prefetchQuery<TResult, TError>(\n    ...args: any[]\n  ): Promise<TResult | undefined> {\n    if (\n      isObject(args[1]) &&\n      (args[1].hasOwnProperty('throwOnError') ||\n        args[1].hasOwnProperty('force'))\n    ) {\n      args[3] = args[1]\n      args[1] = undefined\n      args[2] = undefined\n    }\n\n    const [queryKey, config, options] = getQueryArgs<\n      TResult,\n      TError,\n      PrefetchQueryOptions | undefined\n    >(args)\n    // https://github.com/tannerlinsley/react-query/issues/652\n    const configWithoutRetry = { retry: false, ...config }\n\n    try {\n      const query = this.buildQuery<TResult, TError>(\n        queryKey,\n        configWithoutRetry\n      )\n      if (options?.force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (options?.throwOnError) {\n        throw err\n      }\n      Console.error(err)\n      return\n    }\n  }\n\n  setQueryData<TResult, TError = unknown>(\n    queryKey: QueryKey,\n    updater: Updater<TResult | undefined, TResult>,\n    config: QueryConfig<TResult, TError> = {}\n  ) {\n    let query = this.getQuery<TResult, TError>(queryKey)\n\n    if (!query) {\n      query = this.buildQuery<TResult, TError>(queryKey, config)\n    }\n\n    query.setData(updater)\n  }\n}\n\nexport const queryCache = makeQueryCache({ frozen: isServer })\n\nexport const queryCaches = [queryCache]\n\nexport function makeQueryCache(config?: QueryCacheConfig) {\n  return new QueryCache(config)\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\ntype FocusHandler = () => void\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus: FocusHandler = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (!query.instances.some(instance => instance.config.enabled)) {\n            return false\n          }\n\n          if (!query.state.isStale) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n          }\n\n          return Boolean(query.config.refetchOnWindowFocus)\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler: (() => void) | void\n\nexport function setFocusHandler(callback: (callback: FocusHandler) => void) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler((handleFocus: FocusHandler) => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n  return\n})\n","import React from 'react'\n\nimport {\n  queryCache as defaultQueryCache,\n  queryCaches,\n  makeQueryCache,\n} from '../core'\nimport { QueryCache } from '../core/queryCache'\n\nexport const queryCacheContext = React.createContext(defaultQueryCache)\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport interface ReactQueryCacheProviderProps {\n  queryCache?: QueryCache\n}\n\nexport const ReactQueryCacheProvider: React.FC<ReactQueryCacheProviderProps> = ({\n  queryCache,\n  children,\n}) => {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear({ notify: false })\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { DEFAULT_CONFIG, defaultConfigRef } from '../core/config'\nimport { ReactQueryConfig } from '../core/types'\n\nconst configContext = React.createContext<ReactQueryConfig | undefined>(\n  undefined\n)\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport interface ReactQueryProviderConfig extends ReactQueryConfig {}\n\nexport interface ReactQueryConfigProviderProps {\n  config: ReactQueryProviderConfig\n}\n\nexport const ReactQueryConfigProvider: React.FC<ReactQueryConfigProviderProps> = ({\n  config,\n  children,\n}) => {\n  const configContextValueOrDefault = useConfigContext()\n  const configContextValue = React.useContext(configContext)\n\n  const newConfig = React.useMemo<ReactQueryConfig>(() => {\n    const { shared = {}, queries = {}, mutations = {} } = config\n    const {\n      shared: contextShared = {},\n      queries: contextQueries = {},\n      mutations: contextMutations = {},\n    } = configContextValueOrDefault\n\n    return {\n      shared: {\n        ...contextShared,\n        ...shared,\n      },\n      queries: {\n        ...contextQueries,\n        ...queries,\n      },\n      mutations: {\n        ...contextMutations,\n        ...mutations,\n      },\n    }\n  }, [config, configContextValueOrDefault])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = {\n        ...(configContextValueOrDefault || DEFAULT_CONFIG),\n      }\n    }\n  }, [configContextValueOrDefault])\n\n  // If this is the outermost provider, overwrite the shared default config\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { uid, isServer } from '../core/utils'\nimport { QueryResultBase, QueryStatus } from '../core/types'\n\nexport function useUid(): number {\n  const ref = React.useRef(0)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function useGetLatest<T>(obj: T): () => T {\n  const ref = React.useRef<T>(obj)\n  ref.current = obj\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function useMountedCallback<T extends Function>(callback: T): T {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => {\n      mounted.current = false\n    }\n  }, [])\n\n  return (React.useCallback(\n    (...args: any[]) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  ) as any) as T\n}\n\nexport function useRerenderer() {\n  const rerender = useMountedCallback(React.useState<unknown>()[1])\n  return React.useCallback(() => rerender({}), [rerender])\n}\n\nexport function handleSuspense(result: QueryResultBase<any, any>) {\n  const { error, query } = result\n  const { config, state } = query\n\n  if (config.suspense || config.useErrorBoundary) {\n    if (state.status === QueryStatus.Error && state.throwInErrorBoundary) {\n      throw error\n    }\n\n    if (\n      config.suspense &&\n      state.status !== QueryStatus.Success &&\n      config.enabled\n    ) {\n      query.wasSuspended = true\n      throw query.fetch()\n    }\n  }\n}\n","import React from 'react'\n\nimport { useRerenderer, useGetLatest } from './utils'\nimport { useQueryCache } from './ReactQueryCacheProvider'\n\nexport function useIsFetching(): number {\n  const queryCache = useQueryCache()\n  const rerender = useRerenderer()\n  const isFetching = queryCache.isFetching\n\n  const getIsFetching = useGetLatest(isFetching)\n\n  React.useEffect(\n    () =>\n      queryCache.subscribe(newCache => {\n        if (getIsFetching() !== newCache.isFetching) {\n          rerender()\n        }\n      }),\n    [getIsFetching, queryCache, rerender]\n  )\n\n  return isFetching\n}\n","import React from 'react'\n\nimport { useConfigContext } from './ReactQueryConfigProvider'\nimport { useGetLatest, useMountedCallback } from './utils'\nimport { Console, uid, getStatusProps } from '../core/utils'\nimport {\n  QueryStatus,\n  MutationResultPair,\n  MutationFunction,\n  MutationConfig,\n  MutateConfig,\n} from '../core/types'\n\n// TYPES\n\ntype Reducer<S, A> = (prevState: S, action: A) => S\n\ninterface State<TResult, TError> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n}\n\nenum ActionType {\n  Reset = 'Reset',\n  Loading = 'Loading',\n  Resolve = 'Resolve',\n  Reject = 'Reject',\n}\n\ninterface ResetAction {\n  type: ActionType.Reset\n}\n\ninterface LoadingAction {\n  type: ActionType.Loading\n}\n\ninterface ResolveAction<TResult> {\n  type: ActionType.Resolve\n  data: TResult\n}\n\ninterface RejectAction<TError> {\n  type: ActionType.Reject\n  error: TError\n}\n\ntype Action<TResult, TError> =\n  | ResetAction\n  | LoadingAction\n  | ResolveAction<TResult>\n  | RejectAction<TError>\n\n// HOOK\n\nconst getDefaultState = (): State<any, any> => ({\n  ...getStatusProps(QueryStatus.Idle),\n  data: undefined,\n  error: null,\n})\n\nfunction mutationReducer<TResult, TError>(\n  state: State<TResult, TError>,\n  action: Action<TResult, TError>\n): State<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Reset:\n      return getDefaultState()\n    case ActionType.Loading:\n      return {\n        ...getStatusProps(QueryStatus.Loading),\n        data: undefined,\n        error: null,\n      }\n    case ActionType.Resolve:\n      return {\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n      }\n    case ActionType.Reject:\n      return {\n        ...getStatusProps(QueryStatus.Error),\n        data: undefined,\n        error: action.error,\n      }\n    default:\n      return state\n  }\n}\n\nexport function useMutation<\n  TResult,\n  TError = unknown,\n  TVariables = undefined,\n  TSnapshot = unknown\n>(\n  mutationFn: MutationFunction<TResult, TVariables>,\n  config: MutationConfig<TResult, TError, TVariables, TSnapshot> = {}\n): MutationResultPair<TResult, TError, TVariables, TSnapshot> {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer as Reducer<State<TResult, TError>, Action<TResult, TError>>,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const contextConfig = useConfigContext()\n\n  const getConfig = useGetLatest({\n    ...contextConfig.shared,\n    ...contextConfig.mutations,\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef<number>()\n\n  const mutate = React.useCallback(\n    async (\n      variables?: TVariables,\n      mutateConfig: MutateConfig<TResult, TError, TVariables, TSnapshot> = {}\n    ): Promise<TResult | undefined> => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      let snapshotValue: TSnapshot | undefined\n\n      try {\n        dispatch({ type: ActionType.Loading })\n        snapshotValue = (await config.onMutate?.(variables!)) as TSnapshot\n\n        const data = await getMutationFn()(variables!)\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Resolve, data })\n        }\n\n        await config.onSuccess?.(data, variables!)\n        await mutateConfig.onSuccess?.(data, variables!)\n        await config.onSettled?.(data, null, variables!)\n        await mutateConfig.onSettled?.(data, null, variables!)\n\n        return data\n      } catch (error) {\n        Console.error(error)\n        await config.onError?.(error, variables!, snapshotValue!)\n        await mutateConfig.onError?.(error, variables!, snapshotValue!)\n        await config.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue as TSnapshot\n        )\n        await mutateConfig.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue\n        )\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Reject, error })\n        }\n\n        if (mutateConfig.throwOnError ?? config.throwOnError) {\n          throw error\n        }\n\n        return\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => {\n    dispatch({ type: ActionType.Reset })\n  }, [dispatch])\n\n  React.useEffect(() => {\n    const { suspense, useErrorBoundary } = getConfig()\n\n    if ((useErrorBoundary ?? suspense) && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [mutate, { ...state, reset }]\n}\n","import React from 'react'\n\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useRerenderer } from './utils'\nimport { QueryInstance } from '../core/queryInstance'\nimport { QueryConfig, QueryKey, QueryResultBase } from '../core/types'\n\nexport function useBaseQuery<TResult, TError>(\n  queryKey: QueryKey,\n  config: QueryConfig<TResult, TError> = {}\n): QueryResultBase<TResult, TError> {\n  // Make a rerender function\n  const rerender = useRerenderer()\n\n  // Get the query cache\n  const queryCache = useQueryCache()\n\n  // Build the query for use\n  const query = queryCache.buildQuery<TResult, TError>(queryKey, config)\n  const state = query.state\n\n  // Create a query instance ref\n  const instanceRef = React.useRef<QueryInstance<TResult, TError>>()\n\n  // Subscribe to the query when the subscribe function changes\n  React.useEffect(() => {\n    const instance = query.subscribe(() => {\n      rerender()\n    })\n\n    instanceRef.current = instance\n\n    // Unsubscribe when things change\n    return () => instance.unsubscribe()\n  }, [query, rerender])\n\n  // Always update the config\n  React.useEffect(() => {\n    instanceRef.current?.updateConfig(config)\n  })\n\n  const enabledBool = Boolean(config.enabled)\n\n  // Run the instance when the query or enabled change\n  React.useEffect(() => {\n    if (enabledBool && query) {\n      // Just for change detection\n    }\n    instanceRef.current?.run()\n  }, [enabledBool, query])\n\n  const clear = React.useMemo(() => query.clear.bind(query), [query])\n  const refetch = React.useMemo(() => query.refetch.bind(query), [query])\n\n  return {\n    clear,\n    error: state.error,\n    failureCount: state.failureCount,\n    isError: state.isError,\n    isFetching: state.isFetching,\n    isIdle: state.isIdle,\n    isLoading: state.isLoading,\n    isStale: state.isStale,\n    isSuccess: state.isSuccess,\n    query,\n    refetch,\n    status: state.status,\n    updatedAt: state.updatedAt,\n  }\n}\n","import { getQueryArgs } from '../core/utils'\nimport { useConfigContext } from './ReactQueryConfigProvider'\nimport { QueryConfig, QueryKey } from '../core/types'\n\nexport function useQueryArgs<TResult, TError, TOptions = undefined>(\n  args: any[]\n): [QueryKey, QueryConfig<TResult, TError>, TOptions] {\n  const configContext = useConfigContext()\n\n  const [queryKey, config, options] = getQueryArgs<TResult, TError, TOptions>(\n    args\n  )\n\n  // Build the final config\n  const configWithContext = {\n    ...configContext.shared,\n    ...configContext.queries,\n    ...config,\n  } as QueryConfig<TResult, TError>\n\n  return [queryKey, configWithContext, options]\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { handleSuspense } from './utils'\nimport {\n  QueryConfig,\n  QueryKey,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObject,\n  QueryKeyWithoutObjectAndArray,\n  QueryResult,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from '../core/types'\nimport { useQueryArgs } from './useQueryArgs'\n\n// TYPES\n\nexport interface UseQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, [TKey]>\n  config?: QueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useQuery<TResult, TError, TKey extends QueryKeyWithoutObject>(\n  queryKey: TKey,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObjectAndArray\n>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, [TKey]>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<TResult, TError, TKey extends TupleQueryKey>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, TKey>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Object syntax\nexport function useQuery<TResult, TError, TKey extends QueryKeyWithoutArray>(\n  config: UseQueryObjectConfig<TResult, TError, [TKey]>\n): QueryResult<TResult, TError>\n\nexport function useQuery<TResult, TError, TKey extends TupleQueryKey>(\n  config: UseQueryObjectConfig<TResult, TError, TKey>\n): QueryResult<TResult, TError>\n\n// Implementation\nexport function useQuery<TResult, TError>(\n  ...args: any[]\n): QueryResult<TResult, TError> {\n  const [queryKey, config] = useQueryArgs<TResult, TError>(args)\n  const result = useBaseQuery<TResult, TError>(queryKey, config)\n\n  handleSuspense(result)\n\n  return {\n    ...result,\n    data: result.query.state.data,\n  }\n}\n","import React from 'react'\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { handleSuspense } from './utils'\nimport { getStatusProps } from '../core/utils'\nimport {\n  PaginatedQueryConfig,\n  PaginatedQueryResult,\n  QueryKey,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObject,\n  QueryKeyWithoutObjectAndArray,\n  QueryStatus,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from '../core/types'\nimport { useQueryArgs } from './useQueryArgs'\n\n// A paginated query is more like a \"lag\" query, which means\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n\n// TYPES\n\nexport interface UsePaginatedQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, TKey>\n  config?: PaginatedQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObject\n>(\n  queryKey: TKey,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObjectAndArray\n>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, [TKey]>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult, TError, TKey extends TupleQueryKey>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, TKey>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Object syntax\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutArray\n>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError, [TKey]>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult, TError, TKey extends TupleQueryKey>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError, TKey>\n): PaginatedQueryResult<TResult, TError>\n\n// Implementation\nexport function usePaginatedQuery<TResult, TError>(\n  ...args: any[]\n): PaginatedQueryResult<TResult, TError> {\n  const [queryKey, config] = useQueryArgs<TResult, TError>(args)\n\n  // Keep track of the latest data result\n  const lastDataRef = React.useRef<TResult>()\n\n  // If latestData is there, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  // Make the query as normal\n  const result = useBaseQuery<TResult, TError>(queryKey, config)\n\n  // If the query is disabled, get rid of the latest data\n  if (!result.query.config.enabled) {\n    lastDataRef.current = undefined\n  }\n\n  // Get the real data and status from the query\n  const { data: latestData, status } = result.query.state\n\n  // If the real query succeeds, and there is data in it,\n  // update the latest data\n  React.useEffect(() => {\n    if (status === QueryStatus.Success && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  // Resolved data should be either the real data we're waiting on\n  // or the latest placeholder data\n  let resolvedData = latestData\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  // If we have any data at all from either, we\n  // need to make sure the status is success, even though\n  // the real query may still be loading\n  if (typeof resolvedData !== 'undefined') {\n    const overrides = getStatusProps(QueryStatus.Success)\n    Object.assign(result.query.state, overrides)\n    Object.assign(result, overrides)\n  }\n\n  handleSuspense(result)\n\n  return {\n    ...result,\n    resolvedData,\n    latestData,\n  }\n}\n","import React from 'react'\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { handleSuspense } from './utils'\nimport {\n  InfiniteQueryConfig,\n  InfiniteQueryResult,\n  QueryKey,\n  QueryKeyWithoutArray,\n  QueryKeyWithoutObject,\n  QueryKeyWithoutObjectAndArray,\n  TupleQueryFunction,\n  TupleQueryKey,\n} from '../core/types'\nimport { useQueryArgs } from './useQueryArgs'\n\n// TYPES\n\nexport interface UseInfiniteQueryObjectConfig<\n  TResult,\n  TError,\n  TKey extends TupleQueryKey\n> {\n  queryKey: QueryKey\n  queryFn?: TupleQueryFunction<TResult, TKey>\n  config?: InfiniteQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObject\n>(\n  queryKey: TKey,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutObjectAndArray\n>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, [TKey]>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult, TError, TKey extends TupleQueryKey>(\n  queryKey: TKey,\n  queryFn: TupleQueryFunction<TResult, TKey>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Object syntax\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TKey extends QueryKeyWithoutArray\n>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError, [TKey]>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult, TError, TKey extends TupleQueryKey>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError, TKey>\n): InfiniteQueryResult<TResult, TError>\n\n// Implementation\nexport function useInfiniteQuery<TResult, TError>(\n  ...args: any[]\n): InfiniteQueryResult<TResult, TError> {\n  const [queryKey, config] = useQueryArgs<TResult[], TError>(args)\n\n  config.infinite = true\n\n  const result = useBaseQuery<TResult[], TError>(queryKey, config)\n  const query = result.query\n  const state = result.query.state\n\n  handleSuspense(result)\n\n  const fetchMore = React.useMemo(() => query.fetchMore.bind(query), [query])\n\n  return {\n    ...result,\n    data: state.data,\n    canFetchMore: state.canFetchMore,\n    fetchMore,\n    isFetching: state.isFetching,\n    isFetchingMore: state.isFetchingMore,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}